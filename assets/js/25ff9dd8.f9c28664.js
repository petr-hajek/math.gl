"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7386],{5301:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});var r=n(5893),t=n(1151);const c={},o="View and Projection Matrices",s={id:"developer-guide/math/view-and-projection",title:"View and Projection Matrices",description:'One of the major functions of any 3D math library is to let applications create view and projection matrices to enable positioning of the viewer in a 3D world and projection of 3D geometries via a field-of-view onto a flat "screen".',source:"@site/../docs/developer-guide/math/view-and-projection.md",sourceDirName:"developer-guide/math",slug:"/developer-guide/math/view-and-projection",permalink:"/math.gl/docs/developer-guide/math/view-and-projection",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/website/../docs/developer-guide/math/view-and-projection.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Transformations",permalink:"/math.gl/docs/developer-guide/math/transformations"},next:{title:"Homogeneous Coordinates",permalink:"/math.gl/docs/developer-guide/math/homogeneous-coordinates"}},a={},l=[{value:"View Matrices",id:"view-matrices",level:2},{value:"Creating a View Matrix",id:"creating-a-view-matrix",level:3},{value:"Projection Matrices",id:"projection-matrices",level:2},{value:"Perspective Projection Matrix",id:"perspective-projection-matrix",level:3},{value:"Orthographic Projection Matrix",id:"orthographic-projection-matrix",level:3},{value:"Switching between Perspective and Orthographic Views",id:"switching-between-perspective-and-orthographic-views",level:3},{value:"About Projection Matrices",id:"about-projection-matrices",level:2},{value:"Decomposing a ViewProjection Matrix",id:"decomposing-a-viewprojection-matrix",level:2},{value:"Remarks",id:"remarks",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.h1,{id:"view-and-projection-matrices",children:"View and Projection Matrices"}),"\n",(0,r.jsx)(i.p,{children:'One of the major functions of any 3D math library is to let applications create view and projection matrices to enable positioning of the viewer in a 3D world and projection of 3D geometries via a field-of-view onto a flat "screen".'}),"\n",(0,r.jsx)(i.p,{children:"To set up a 4x4 view projection matrix you need a view matrix (specifying the position, direction and orientation of the camera) and a projection matrix (specifying the characteristics of the camera such as its field of view etc)."}),"\n",(0,r.jsx)(i.h2,{id:"view-matrices",children:"View Matrices"}),"\n",(0,r.jsxs)(i.p,{children:["The purpose of the view matrix is to translate and rotate your world coordinates so that the eye is located in the origin ",(0,r.jsx)(i.code,{children:"[0, 0, 0]"}),", looking down the positive ",(0,r.jsx)(i.code,{children:"Z"})," axis, rotated so that the right direction is ",(0,r.jsx)(i.code,{children:"up"}),'. This is called the "view coordinate system".']}),"\n",(0,r.jsxs)(i.p,{children:['The purpose of the projection matrix is to transform from view coordinates to "clipspace" coordinates (which is the only coordinate system that the GPU can work directly with). If a point is between ',(0,r.jsx)(i.code,{children:"-1"})," and ",(0,r.jsx)(i.code,{children:"1"})," (after ",(0,r.jsx)(i.code,{children:"w"})," scaling) in clipspace, it will be rendered. The ",(0,r.jsx)(i.code,{children:"z"})," coordinate in clipspace is also scaled (using 'near' and 'far' planes) and if between ",(0,r.jsx)(i.code,{children:"-1"})," and ",(0,r.jsx)(i.code,{children:"1"})," it is used for depth test."]}),"\n",(0,r.jsxs)(i.p,{children:["Note: while a projection matrix may generate coordinates with ",(0,r.jsx)(i.code,{children:"w !== 1"}),", the GPU will automatically divide the ",(0,r.jsx)(i.code,{children:"xyzw"})," coordinates with the ",(0,r.jsx)(i.code,{children:"w"}),' coordinateof any positions it receives thus and "normalize" the ',(0,r.jsx)(i.code,{children:"w"})," coordinate. Thus, there is no need to do this scaling manually in shaders unless doing additional arithmetic in clipspace."]}),"\n",(0,r.jsx)(i.h3,{id:"creating-a-view-matrix",children:"Creating a View Matrix"}),"\n",(0,r.jsx)(i.p,{children:"To create a view matrix"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"Matrix4.lookAt({...})"})}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Normally positions are transformed by the view matrix. If doing work (e.g. lighting) in view space you will also want to transform other geometry such as normals."}),"\n",(0,r.jsx)(i.h2,{id:"projection-matrices",children:"Projection Matrices"}),"\n",(0,r.jsx)(i.p,{children:'A perspective projection typically shows everything inside a frustum (truncated pyramid) or a cube in the view space. Their job is to "scale" or "skew" the geometry inside this virtual shape into the clipspace cube, which is the coordinate system the GPU takes as input.'}),"\n",(0,r.jsxs)(i.p,{children:['This projection matrices map your geometry into a "normalized box" where ',(0,r.jsx)(i.code,{children:"x"})," and ",(0,r.jsx)(i.code,{children:"y"})," values of ",(0,r.jsx)(i.code,{children:"-1"})," and ",(0,r.jsx)(i.code,{children:"1"})," represent the bounds of your screen or frame buffer."]}),"\n",(0,r.jsx)(i.p,{children:"Projection matrices can also be ortographic, meaning that 3D objects are mapped via parallel lines onto the screen, rather than via a frustum."}),"\n",(0,r.jsx)(i.h3,{id:"perspective-projection-matrix",children:"Perspective Projection Matrix"}),"\n",(0,r.jsx)(i.p,{children:"To create a projection matrix use:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"Matrix4.perspective({fov, aspect, near, far})"})}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"orthographic-projection-matrix",children:"Orthographic Projection Matrix"}),"\n",(0,r.jsx)(i.p,{children:'math.gl provides the traditional function create an orhtographic projection matrix by providing the "box" extents:'}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"Matrix4.ortho({right, left, top, bottom, near, far})"})}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:'The extents are specified in "view space" (which is typically translated and rotated, but not scaled, world space).'}),"\n",(0,r.jsx)(i.h3,{id:"switching-between-perspective-and-orthographic-views",children:"Switching between Perspective and Orthographic Views"}),"\n",(0,r.jsxs)(i.p,{children:["In applications it is not unusual to want to offer both perspective and orthographic views. To support this case, math.gl offers an additional method for creating orthographic projection matrix, that takes the same parameters as ",(0,r.jsx)(i.code,{children:"Matrix4.perspective()"}),", with the addition of one additional parameter, ",(0,r.jsx)(i.code,{children:"focalDistance"})," that selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box."]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"Matrix4.orthographic({fovy, aspect, focalDistance, near, far})"})}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"about-projection-matrices",children:"About Projection Matrices"}),"\n",(0,r.jsx)(i.p,{children:"An ortograhic projection matrix scales your view to show everything within a box. As can be seen in the matrix below, it centers your view between the bounds of the box, and scales your positions so that the box limits fall on -1 and +1 in each direction. It also does an inversion of the X and Y coordinates."}),"\n",(0,r.jsx)("math",{display:"block",children:(0,r.jsxs)("mrow",{children:[(0,r.jsx)("mfenced",{open:"[",close:"]",children:(0,r.jsxs)("mtable",{children:[(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"scale"}),(0,r.jsx)("mn",{children:"x"})]})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"translate"}),(0,r.jsx)("mi",{children:"x"})]})})]}),(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"scale"}),(0,r.jsx)("mn",{children:"y"})]})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"translate"}),(0,r.jsx)("mi",{children:"y"})]})})]}),(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"scale"}),(0,r.jsx)("mn",{children:"z"})]})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"translate"}),(0,r.jsx)("mi",{children:"z"})]})})]}),(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mi",{children:"..."})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("msub",{children:[(0,r.jsx)("mi",{children:"scale"}),(0,r.jsx)("mi",{children:"global"})]})})]})]})}),(0,r.jsx)("mo",{children:"="}),(0,r.jsx)("mfenced",{open:"[",close:"]",children:(0,r.jsxs)("mtable",{children:[(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("mfrac",{children:[(0,r.jsx)("mn",{children:"-2"}),(0,r.jsx)("mi",{children:"left - right"})]})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("mfrac",{children:[(0,r.jsx)("mi",{children:"left + right"}),(0,r.jsx)("mi",{children:"left - right"})]})})]}),(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("mfrac",{children:[(0,r.jsx)("mn",{children:"-2"}),(0,r.jsx)("mi",{children:"bottom - top"})]})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("mfrac",{children:[(0,r.jsx)("mi",{children:"bottom + top"}),(0,r.jsx)("mi",{children:"bottom - top"})]})})]}),(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("mfrac",{children:[(0,r.jsx)("mn",{children:"2"}),(0,r.jsx)("mi",{children:"near - far"})]})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsxs)("mfrac",{children:[(0,r.jsx)("mi",{children:"near + far"}),(0,r.jsx)("mi",{children:"near - far"})]})})]}),(0,r.jsxs)("mtr",{children:[(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"0"})}),(0,r.jsx)("mtd",{columnalign:"center",children:(0,r.jsx)("mn",{children:"1"})})]})]})})]})}),"\n",(0,r.jsx)(i.h2,{id:"decomposing-a-viewprojection-matrix",children:"Decomposing a ViewProjection Matrix"}),"\n",(0,r.jsx)(i.p,{children:"TBA"}),"\n",(0,r.jsx)(i.h2,{id:"remarks",children:"Remarks"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"As always, matrices are presented here in row major notation, however math.gl stores them internally in column major format to match WebGL conventions."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>s,a:()=>o});var r=n(7294);const t={},c=r.createContext(t);function o(e){const i=r.useContext(c);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(c.Provider,{value:i},e.children)}}}]);