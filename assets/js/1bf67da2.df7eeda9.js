"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7214],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>y});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var m=r.createContext({}),u=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=u(e.components);return r.createElement(m.Provider,{value:n},e.children)},s="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,m=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),s=u(t),d=a,y=s["".concat(m,".").concat(d)]||s[d]||g[d]||i;return t?r.createElement(y,l(l({ref:n},p),{},{components:t})):r.createElement(y,l({ref:n},p))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=d;var o={};for(var m in n)hasOwnProperty.call(n,m)&&(o[m]=n[m]);o.originalType=e,o[s]="string"==typeof e?e:a,l[1]=o;for(var u=2;u<i;u++)l[u]=t[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9479:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=t(8168),a=(t(6540),t(5680));const i={},l="Matrix4",o={unversionedId:"modules/core/api-reference/matrix4",id:"modules/core/api-reference/matrix4",title:"Matrix4",description:"A 4x4 matrix. Any arguments to Matrix4 methods can be plain JavaScript arrays or other math.gl objects.",source:"@site/../docs/modules/core/api-reference/matrix4.md",sourceDirName:"modules/core/api-reference",slug:"/modules/core/api-reference/matrix4",permalink:"/math.gl/docs/modules/core/api-reference/matrix4",draft:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/core/api-reference/matrix4.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Matrix3",permalink:"/math.gl/docs/modules/core/api-reference/matrix3"},next:{title:"Pose",permalink:"/math.gl/docs/modules/core/api-reference/pose"}},m={},u=[{value:"Usage",id:"usage",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>constructor()</code>",id:"constructor",level:5},{value:"<code>identity(): this</code>",id:"identity-this",level:5},{value:"<code>set(...number): this</code>",id:"setnumber-this",level:5},{value:"<code>fromQuaternion(quaternion: Quaternion): this</code>",id:"fromquaternionquaternion-quaternion-this",level:5},{value:"<code>frustum(options: {left: number, right: number, bottom: number, top: number, near: number, far: number}): this</code>",id:"frustumoptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this",level:5},{value:"<code>lookAt(options?: {eye: number, center: number, up: number}): this</code>",id:"lookatoptions-eye-number-center-number-up-number-this",level:5},{value:"<code>ortho(options: {left: number, right: number, bottom: number, top: number, near?: number, far: number}): this</code>",id:"orthooptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this",level:5},{value:"<code>orthographic()</code>",id:"orthographic",level:5},{value:"<code>perspective()</code>",id:"perspective",level:5},{value:"<code>determinant(): number</code>",id:"determinant-number",level:5},{value:"<code>transpose(): this</code>",id:"transpose-this",level:5},{value:"<code>invert(): this</code>",id:"invert-this",level:5},{value:"<code>multiplyLeft(matrix: number[16]): this</code>",id:"multiplyleftmatrix-number16-this",level:5},{value:"<code>multiplyRight(matrix: number[16]): this</code>",id:"multiplyrightmatrix-number16-this",level:5},{value:"<code>rotateX(radians: number): this</code>",id:"rotatexradians-number-this",level:5},{value:"<code>rotateY(radians: number): this</code>",id:"rotateyradians-number-this",level:5},{value:"<code>rotateZ(radians: number): this</code>",id:"rotatezradians-number-this",level:5},{value:"<code>rotateXYZ(angles: [rx: number, ry: number, rz: </code>number]): this",id:"rotatexyzangles-rx-number-ry-number-rz-number-this",level:5},{value:"<code>rotateAxis(radians: number, axis: number[3]): this</code>",id:"rotateaxisradians-number-axis-number3-this",level:5},{value:"<code>scale(factor: number | number[3]): this</code>",id:"scalefactor-number--number3-this",level:5},{value:"<code>translate(scale: number[3]): this</code>",id:"translatescale-number3-this",level:5},{value:"Decomposition",id:"decomposition",level:4},{value:"<code>getRotation(result?: number[16]) : number[16]</code>",id:"getrotationresult-number16--number16",level:5},{value:"<code>getRotationMatrix3(result?: number[9]) : number[9]</code>",id:"getrotationmatrix3result-number9--number9",level:5},{value:"<code>getTranslation(result?: number[3]) : number[3]</code>",id:"gettranslationresult-number3--number3",level:5},{value:"<code>getScale(result?: number[3]) : number[3]</code>",id:"getscaleresult-number3--number3",level:5},{value:"Point Transformations",id:"point-transformations",level:4},{value:"<code>transformAsPoint(vector : number[4]) : number[4]</code>",id:"transformaspointvector--number4--number4",level:5},{value:"<code>transformAsVector(vector : number[4]) : number[4]</code>",id:"transformasvectorvector--number4--number4",level:5},{value:"Remarks",id:"remarks",level:2}],p={toc:u},s="wrapper";function g(e){let{components:n,...t}=e;return(0,a.yg)(s,(0,r.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"matrix4"},"Matrix4"),(0,a.yg)("p",null,"A 4x4 matrix. Any arguments to ",(0,a.yg)("inlineCode",{parentName:"p"},"Matrix4")," methods can be plain JavaScript arrays or other ",(0,a.yg)("inlineCode",{parentName:"p"},"math.gl")," objects."),(0,a.yg)("h2",{id:"usage"},"Usage"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"import {Matrix4} from `math.gl`;\n")),(0,a.yg)("p",null,"Copy a matrix to a ",(0,a.yg)("inlineCode",{parentName:"p"},"Matrix4")," so that it can be manipulated (and mutated) with ",(0,a.yg)("inlineCode",{parentName:"p"},"Matrix4")," methods:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const IDENTITY = [1, 0, ..., 1];\nconst m = new Matrix4(IDENTITY).translate([1, 0, 0]);\n")),(0,a.yg)("p",null,"Create a perspective projection matrix"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const projectionMatrix = new Matrix4().perspective({fov, aspect, near, far});\n")),(0,a.yg)("p",null,"Create an orthograhic projection matrix"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"")),(0,a.yg)("p",null,"Invert a matrix"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const inverse = matrix.invert();\n")),(0,a.yg)("p",null,"Transform a vector as a point (including translations)"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const transform = new Matrix4();\nconst vector2 = transform.transformPoint([0, 0]);\nconst vector3 = transform.transformPoint([0, 1, 2]);\nconst vector4 = transform.transformPoint([0, 1, 2, 1]);\n")),(0,a.yg)("p",null,"Transform a vector as a direction (NOT including translations)"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"const transform = new Matrix4();\nconst vector2 = transform.transformDirection([0, 0]);\nconst vector3 = transform.transformDirection([0, 1, 2]);\nconst vector4 = transform.transformDirection([0, 1, 2, 1]);\n")),(0,a.yg)("h2",{id:"inheritance"},"Inheritance"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"class Matrix4 extends")," ",(0,a.yg)("a",{parentName:"p",href:"/docs/modules/core/api-reference/matrix"},(0,a.yg)("inlineCode",{parentName:"a"},"Matrix"))," ",(0,a.yg)("inlineCode",{parentName:"p"},"extends")," ",(0,a.yg)("a",{parentName:"p",href:"/docs/modules/core/api-reference/math-array"},(0,a.yg)("inlineCode",{parentName:"a"},"MathArray"))," ",(0,a.yg)("inlineCode",{parentName:"p"},"extends")," ",(0,a.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"},(0,a.yg)("inlineCode",{parentName:"a"},"Array")),"`"),(0,a.yg)("p",null,"Many basic methods are inherited:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.clone()")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.copy(array)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.set(...args)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.fromArray(array, offset = 0)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.toString()")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.toArray(array = [], offset = 0)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.equals(array)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.exactEquals(array)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.validate(array = this)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.check(array = this)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"matrix4.normalize()"))),(0,a.yg)("p",null,"Since ",(0,a.yg)("inlineCode",{parentName:"p"},"Matrix4")," is a subclass of the built in JavaScript ",(0,a.yg)("inlineCode",{parentName:"p"},"Array")," it can be used directly as a parameter to any function expecting an ",(0,a.yg)("inlineCode",{parentName:"p"},"Array"),"."),(0,a.yg)("h2",{id:"methods"},"Methods"),(0,a.yg)("h5",{id:"constructor"},(0,a.yg)("inlineCode",{parentName:"h5"},"constructor()")),(0,a.yg)("p",null,"Creates an empty ",(0,a.yg)("inlineCode",{parentName:"p"},"Matrix4")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"new Matrix4()")),(0,a.yg)("h5",{id:"identity-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"identity(): this")),(0,a.yg)("p",null,"Sets the matrix to the multiplicative identity matrix."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.identity()")),(0,a.yg)("h5",{id:"setnumber-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"set(...number): this")),(0,a.yg)("p",null,"Sets the elements of the matrix."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33)")),(0,a.yg)("h5",{id:"fromquaternionquaternion-quaternion-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"fromQuaternion(quaternion: Quaternion): this")),(0,a.yg)("p",null,"Sets the matrix to a transformation corresponding to the rotations represented by the given quaternion."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.fromQuaternion(quaternion)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"quaternion")," (",(0,a.yg)("inlineCode",{parentName:"li"},"Quaternion"),") - the quaternion to create matrix from")),(0,a.yg)("h5",{id:"frustumoptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"frustum(options: {left: number, right: number, bottom: number, top: number, near: number, far: number}): this")),(0,a.yg)("p",null,"Generates a frustum matrix with the given bounds. The frustum far plane can be infinite."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.frustum({left, right, bottom, top, near, far})")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"left")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Left bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"right")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Right bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"bottom")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Bottom bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"top")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Top bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"near")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Near bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"far")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),"|",(0,a.yg)("inlineCode",{parentName:"li"},"Infinity"),") - Far bound of the frustum")),(0,a.yg)("h5",{id:"lookatoptions-eye-number-center-number-up-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"lookAt(options?: {eye: number, center: number, up: number}): this")),(0,a.yg)("p",null,"Generates a look-at matrix with the given eye position, focal point, and up axis"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.lookAt({eye, center, up})")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"eye")," (",(0,a.yg)("inlineCode",{parentName:"li"},"Vector3"),"|",(0,a.yg)("inlineCode",{parentName:"li"},"number[3]"),") - Position of the viewer"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"center"),"=",(0,a.yg)("inlineCode",{parentName:"li"},"[0, 0, 0]")," (",(0,a.yg)("inlineCode",{parentName:"li"},"Vector3"),"|",(0,a.yg)("inlineCode",{parentName:"li"},"number[3]"),") vec3 Point the viewer is looking at"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"up"),"=",(0,a.yg)("inlineCode",{parentName:"li"},"[0, 1, 0]")," (",(0,a.yg)("inlineCode",{parentName:"li"},"Vector3"),"|",(0,a.yg)("inlineCode",{parentName:"li"},"number[3]"),") vec3 vec3 pointing up")),(0,a.yg)("h5",{id:"orthooptions-left-number-right-number-bottom-number-top-number-near-number-far-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"ortho(options: {left: number, right: number, bottom: number, top: number, near?: number, far: number}): this")),(0,a.yg)("p",null,"Generates a orthogonal projection matrix with the given bounds"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.ortho({left, right, bottom, top, near = 0.1, far = 500})")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"left")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Left bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"right")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Right bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"bottom")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Bottom bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"top")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Top bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"near")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Near bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"far")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Far bound of the frustum")),(0,a.yg)("h5",{id:"orthographic"},(0,a.yg)("inlineCode",{parentName:"h5"},"orthographic()")),(0,a.yg)("p",null,"Generates an orthogonal projection matrix with the same parameters\nas a perspective matrix (plus ",(0,a.yg)("inlineCode",{parentName:"p"},"focalDistance"),")."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"Matrix4.orthographic({fovy, aspect, focalDistance, near, far})"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"fovy")," (",(0,a.yg)("inlineCode",{parentName:"p"},"number"),") - Vertical field of view in radians")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"aspect")," (",(0,a.yg)("inlineCode",{parentName:"p"},"number"),") - Aspect ratio. typically viewport width/height")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"focalDistance")," (",(0,a.yg)("inlineCode",{parentName:"p"},"number"),") - selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"near"),"=",(0,a.yg)("inlineCode",{parentName:"p"},"0.1")," (",(0,a.yg)("inlineCode",{parentName:"p"},"number"),") - Near bound of the frustum")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"far"),"=",(0,a.yg)("inlineCode",{parentName:"p"},"500")," (",(0,a.yg)("inlineCode",{parentName:"p"},"number"),") - Far bound of the frustum"))),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"In applications it is not unusual to want to offer both perspective and orthographic views and this method is supplied to make this as simple as possible.")),(0,a.yg)("h5",{id:"perspective"},(0,a.yg)("inlineCode",{parentName:"h5"},"perspective()")),(0,a.yg)("p",null,"Generates a perspective projection matrix with the given bounds. The frustum far plane can be infinite."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.perspective({ fovy = 45 * Math.PI - / 180, aspect = 1, near = 0.1, far = 500 })")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"fovy"),"=",(0,a.yg)("inlineCode",{parentName:"li"},"45")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Vertical field of view in radians (default is 45 degrees specified in radians)"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"aspect"),"=",(0,a.yg)("inlineCode",{parentName:"li"},"1")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Aspect ratio. typically viewport width/height"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"near"),"=",(0,a.yg)("inlineCode",{parentName:"li"},"0.1")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),") - Near bound of the frustum"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"far"),"=",(0,a.yg)("inlineCode",{parentName:"li"},"500")," (",(0,a.yg)("inlineCode",{parentName:"li"},"number"),"|",(0,a.yg)("inlineCode",{parentName:"li"},"Infinity"),") - Far bound of the frustum")),(0,a.yg)("h5",{id:"determinant-number"},(0,a.yg)("inlineCode",{parentName:"h5"},"determinant(): number")),(0,a.yg)("p",null,"Returns the determinant of the matrix (does not modify the matrix)."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"const determinant = matrix4.determinant()")),(0,a.yg)("p",null,"Returns (",(0,a.yg)("inlineCode",{parentName:"p"},"number"),") - the determinant"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If the determinant is zero, the matrix is not invertible."),(0,a.yg)("li",{parentName:"ul"},"Determinant calculation is somewhat expensive.")),(0,a.yg)("h5",{id:"transpose-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"transpose(): this")),(0,a.yg)("p",null,"Sets this matrix to its transpose matrix."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.transpose()")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The transpose matrix mirrors the original matrix elements in the diagonal.")),(0,a.yg)("h5",{id:"invert-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"invert(): this")),(0,a.yg)("p",null,"Sets this matrix to its inverse matrix."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.invert()")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The inverse matrix mirrors the original matrix elements in the diagonal.")),(0,a.yg)("h5",{id:"multiplyleftmatrix-number16-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"multiplyLeft(matrix: number[16]): this")),(0,a.yg)("p",null,"Multiplies in another matrix from the left"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.multiplyLeft(matrix4)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"When using ",(0,a.yg)("inlineCode",{parentName:"li"},"Matrix4")," to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).")),(0,a.yg)("h5",{id:"multiplyrightmatrix-number16-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"multiplyRight(matrix: number[16]): this")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.multiplyRight(matrix4)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"When using ",(0,a.yg)("inlineCode",{parentName:"li"},"Matrix4")," to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).")),(0,a.yg)("h5",{id:"rotatexradians-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"rotateX(radians: number): this")),(0,a.yg)("p",null,"Adds a rotation by the given angle around the X axis. Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.rotateX(radians)")),(0,a.yg)("h5",{id:"rotateyradians-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"rotateY(radians: number): this")),(0,a.yg)("p",null,"Adds a rotation by the given angle around the Y axis."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"rotateY(radians)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Equivalent to right multiplying the new transform into the matrix but more performant.")),(0,a.yg)("h5",{id:"rotatezradians-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"rotateZ(radians: number): this")),(0,a.yg)("p",null,"Adds a rotation by the given angle around the Z axis."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.rotateZ(radians)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Equivalent to right multiplying the new transform into the matrix but more performant.")),(0,a.yg)("h5",{id:"rotatexyzangles-rx-number-ry-number-rz-number-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"rotateXYZ(angles: [rx: number, ry: number, rz: "),"number]): this"),(0,a.yg)("p",null,"Adds successive rotations by the given angles around the X, Y and Z axis."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"rotateXYZ([rx, ry, rz])")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Equivalent to right multiplying the new transform into the matrix but more performant.")),(0,a.yg)("h5",{id:"rotateaxisradians-number-axis-number3-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"rotateAxis(radians: number, axis: number[3]): this")),(0,a.yg)("p",null,"Adds successive rotations by the given angles around the X, Y and Z axis."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"rotateAxis(radians, axis)")),(0,a.yg)("p",null,"Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.yg)("h5",{id:"scalefactor-number--number3-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"scale(factor: number | number[3]): this")),(0,a.yg)("p",null,"Adds a scaling transform, each axis can be scaled independently."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.scale(factor)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"factor")," (number) - scale factor to be applied to each axis.")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.scale([x, y, z])")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"x")," (number) - scale factor to be multiplied into x component"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"y")," (number) - scale factor to be multiplied into y component"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"z")," (number) - scale factor to be multiplied into z component")),(0,a.yg)("p",null,"Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"During vector transformation all coordinates will be multiplied with the given factors."),(0,a.yg)("li",{parentName:"ul"},"Scale with ",(0,a.yg)("inlineCode",{parentName:"li"},"-1")," will flip the coordinate system in that axis."),(0,a.yg)("li",{parentName:"ul"},"Scale with ",(0,a.yg)("inlineCode",{parentName:"li"},"0")," will drop that component.")),(0,a.yg)("h5",{id:"translatescale-number3-this"},(0,a.yg)("inlineCode",{parentName:"h5"},"translate(scale: number[3]): this")),(0,a.yg)("p",null,"Adds a translation to the matrix."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"matrix4.translate([x, y, z])")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"x")," (number) - translation to be added to the x component"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"y")," (number) - translation to be added to the y component"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"z")," (number) - translation to be added to the z component")),(0,a.yg)("p",null,"Equivalent to right multiplying the new transform into the matrix but more performant."),(0,a.yg)("p",null,"During vector transformation the given translation values are added to each component of the vector being transformed."),(0,a.yg)("h4",{id:"decomposition"},"Decomposition"),(0,a.yg)("h5",{id:"getrotationresult-number16--number16"},(0,a.yg)("inlineCode",{parentName:"h5"},"getRotation(result?: number[16]) : number[16]")),(0,a.yg)("p",null,"Returns a 4x4 rotation matrix."),(0,a.yg)("h5",{id:"getrotationmatrix3result-number9--number9"},(0,a.yg)("inlineCode",{parentName:"h5"},"getRotationMatrix3(result?: number[9]) : number[9]")),(0,a.yg)("p",null,"Returns a 3x3 rotation matrix."),(0,a.yg)("h5",{id:"gettranslationresult-number3--number3"},(0,a.yg)("inlineCode",{parentName:"h5"},"getTranslation(result?: number[3]) : number[3]")),(0,a.yg)("p",null,"Returns the 3-element translation vector component of the affine transform described by the matrix."),(0,a.yg)("p",null,"For performance, an existing vector can be provided, if not a new vector will be returned."),(0,a.yg)("h5",{id:"getscaleresult-number3--number3"},(0,a.yg)("inlineCode",{parentName:"h5"},"getScale(result?: number[3]) : number[3]")),(0,a.yg)("p",null,"Returns the 3-element scale vector component of the affine transform described by the matrix."),(0,a.yg)("p",null,"For performance, an existing vector can be provided, if not a new vector will be returned."),(0,a.yg)("h4",{id:"point-transformations"},"Point Transformations"),(0,a.yg)("h5",{id:"transformaspointvector--number4--number4"},(0,a.yg)("inlineCode",{parentName:"h5"},"transformAsPoint(vector : number[4]) : number[4]")),(0,a.yg)("p",null,'Transforms any 2, 3 or 4 element vector as a "point" by multiplying it (from the right) with this matrix. ',(0,a.yg)("inlineCode",{parentName:"p"},"Point")," here means that the returned vector will include any translations in this matrix."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"const vector = matrix4.transformPoint(vector, out=)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"vector")," (",(0,a.yg)("inlineCode",{parentName:"p"},"Array"),"|",(0,a.yg)("inlineCode",{parentName:"p"},"Vector2"),"|",(0,a.yg)("inlineCode",{parentName:"p"},"Vector3"),"|",(0,a.yg)("inlineCode",{parentName:"p"},"Vector4"),")")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"p"},"out")," - unless supplied, will be a Vector2, Vector3 or Vector4, matching the length of input vector.\nReturns ",(0,a.yg)("inlineCode",{parentName:"p"},"out"),", or a newly minted ",(0,a.yg)("inlineCode",{parentName:"p"},"Vector2"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"Vector3")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"Vector4"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"If ",(0,a.yg)("inlineCode",{parentName:"p"},"vector")," is specified in homogeneous coordinates, ",(0,a.yg)("inlineCode",{parentName:"p"},"w")," coordinate must NOT be ",(0,a.yg)("inlineCode",{parentName:"p"},"0"),".")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"If ",(0,a.yg)("inlineCode",{parentName:"p"},"vector")," is specified in homogeneous coordinates the returned vector will be ",(0,a.yg)("inlineCode",{parentName:"p"},"w")," adjusted, (i.e. ",(0,a.yg)("inlineCode",{parentName:"p"},"w")," coordinate will be ",(0,a.yg)("inlineCode",{parentName:"p"},"1"),", even if the supplied vector was not normalized)."))),(0,a.yg)("h5",{id:"transformasvectorvector--number4--number4"},(0,a.yg)("inlineCode",{parentName:"h5"},"transformAsVector(vector : number[4]) : number[4]")),(0,a.yg)("p",null,"Transforms any 2, 3 or 4 element vector interpreted as a direction (i.e. all vectors are based in the origin so the transformation not pick up any translations from the matrix)."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"const vector = matrix4.transformDirection(vector, out)")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If ",(0,a.yg)("inlineCode",{parentName:"li"},"vector")," is specified in homogeneous coordinates, ",(0,a.yg)("inlineCode",{parentName:"li"},"w")," coordinate must be ",(0,a.yg)("inlineCode",{parentName:"li"},"0"),".")),(0,a.yg)("h2",{id:"remarks"},"Remarks"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},'All transforms are effectively "right multiplied" onto the matrix (meaning that during transform they will be applied in opposite order).'),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"Matrix4")," is stored internally in column major format (per WebGL conventions). This only matters when you read out the matrix to use it with other software.")))}g.isMDXComponent=!0}}]);