"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6674],{5680:(e,n,i)=>{i.d(n,{xA:()=>g,yg:()=>p});var o=i(6540);function t(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function l(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,o)}return i}function a(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?l(Object(i),!0).forEach((function(n){t(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function r(e,n){if(null==e)return{};var i,o,t=function(e,n){if(null==e)return{};var i,o,t={},l=Object.keys(e);for(o=0;o<l.length;o++)i=l[o],n.indexOf(i)>=0||(t[i]=e[i]);return t}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)i=l[o],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var d=o.createContext({}),u=function(e){var n=o.useContext(d),i=n;return e&&(i="function"==typeof e?e(n):a(a({},n),e)),i},g=function(e){var n=u(e.components);return o.createElement(d.Provider,{value:n},e.children)},s="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},c=o.forwardRef((function(e,n){var i=e.components,t=e.mdxType,l=e.originalType,d=e.parentName,g=r(e,["components","mdxType","originalType","parentName"]),s=u(i),c=t,p=s["".concat(d,".").concat(c)]||s[c]||m[c]||l;return i?o.createElement(p,a(a({ref:n},g),{},{components:i})):o.createElement(p,a({ref:n},g))}));function p(e,n){var i=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var l=i.length,a=new Array(l);a[0]=c;var r={};for(var d in n)hasOwnProperty.call(n,d)&&(r[d]=n[d]);r.originalType=e,r[s]="string"==typeof e?e:t,a[1]=r;for(var u=2;u<l;u++)a[u]=i[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,i)}c.displayName="MDXCreateElement"},296:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var o=i(8168),t=(i(6540),i(5680));const l={},a="AxisAlignedBoundingBox",r={unversionedId:"modules/culling/api-reference/axis-aligned-bounding-box",id:"modules/culling/api-reference/axis-aligned-bounding-box",title:"AxisAlignedBoundingBox",description:"An AxisAlignedBoundingBox is a closed and convex cuboid that is aligned with the orthogonal axes.",source:"@site/../docs/modules/culling/api-reference/axis-aligned-bounding-box.md",sourceDirName:"modules/culling/api-reference",slug:"/modules/culling/api-reference/axis-aligned-bounding-box",permalink:"/math.gl/docs/modules/culling/api-reference/axis-aligned-bounding-box",draft:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/culling/api-reference/axis-aligned-bounding-box.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Overview",permalink:"/math.gl/docs/modules/culling/"},next:{title:"BoundingSphere",permalink:"/math.gl/docs/modules/culling/api-reference/bounding-sphere"}},d={},u=[{value:"Inheritance",id:"inheritance",level:2},{value:"Global Functions",id:"global-functions",level:2},{value:"<code>makeAxisAlignedBoundingBoxFromPoints(positions : Array</code>3, result? : AxisAlignedBoundingBox) : AxisAlignedBoundingBox",id:"makeaxisalignedboundingboxfrompointspositions--array3-result--axisalignedboundingbox--axisalignedboundingbox",level:3},{value:"Fields",id:"fields",level:2},{value:"<code>center: Vector3 = [0, 0, 0]</code>",id:"center-vector3--0-0-0",level:3},{value:"<code>halfDiagonal: Vector3</code>",id:"halfdiagonal-vector3",level:3},{value:"<code>minimum: Vector3</code>",id:"minimum-vector3",level:3},{value:"<code>maximum: Vector3</code>",id:"maximum-vector3",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>constructor(minimum = [0, 0, 0], maximum = [0, 0, 0])</code>",id:"constructorminimum--0-0-0-maximum--0-0-0",level:3},{value:"<code>constructor</code>",id:"constructor",level:3},{value:"<code>clone() : AxisAlignedBoundingBox</code>",id:"clone--axisalignedboundingbox",level:3},{value:"<code>equals(right : AxisAlignedBoundingBox) : Boolean</code>",id:"equalsright--axisalignedboundingbox--boolean",level:3},{value:"<code>intersectPlane(plane : Plane) : INTERSECTION</code>",id:"intersectplaneplane--plane--intersection",level:3},{value:"<code>distanceTo(point : Number[3]) : Number</code>",id:"distancetopoint--number3--number",level:3},{value:"<code>distanceSquaredTo(point : Number[3]) : Number</code>",id:"distancesquaredtopoint--number3--number",level:3}],g={toc:u},s="wrapper";function m(e){let{components:n,...i}=e;return(0,t.yg)(s,(0,o.A)({},g,i,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"axisalignedboundingbox"},"AxisAlignedBoundingBox"),(0,t.yg)("p",null,"An ",(0,t.yg)("inlineCode",{parentName:"p"},"AxisAlignedBoundingBox")," is a closed and convex cuboid that is aligned with the orthogonal axes."),(0,t.yg)("h1",{id:"usage"},"Usage"),(0,t.yg)("p",null,(0,t.yg)("inlineCode",{parentName:"p"},"AxisAlignedBoundingBox")," can be created using two corners of the box:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"import {AxisAlignedBoundingBox} from '@math.gl/culling';\n\nconst box = new AxisAlignedBoundingBox([-1, -1, -1], [1, 1, 1]);\n")),(0,t.yg)("p",null,"Or from a collection of points:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"import {makeAxisAlignedBoundingBoxFromPoints} from '@math.gl/culling';\n\nconst box = makeAxisAlignedBoundingBoxFromPoints([\n  [2, 0, 0],\n  [-2, 0, 0]\n]);\n")),(0,t.yg)("h2",{id:"inheritance"},"Inheritance"),(0,t.yg)("p",null,(0,t.yg)("inlineCode",{parentName:"p"},"class AxisAlignedBoundingBox implements")," ",(0,t.yg)("a",{parentName:"p",href:"./bounding-volume"},(0,t.yg)("inlineCode",{parentName:"a"},"BoundingVolume")),"."),(0,t.yg)("h2",{id:"global-functions"},"Global Functions"),(0,t.yg)("h3",{id:"makeaxisalignedboundingboxfrompointspositions--array3-result--axisalignedboundingbox--axisalignedboundingbox"},(0,t.yg)("inlineCode",{parentName:"h3"},"makeAxisAlignedBoundingBoxFromPoints(positions : Array"),"[3][]",", result? : AxisAlignedBoundingBox) : AxisAlignedBoundingBox"),(0,t.yg)("p",null,"Computes an instance of an ",(0,t.yg)("inlineCode",{parentName:"p"},"AxisAlignedBoundingBox")," of the given positions."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"positions")," List of ",(0,t.yg)("inlineCode",{parentName:"li"},"Vector3")," points that the bounding box will enclose."),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"result")," Optional object onto which to store the result.")),(0,t.yg)("h2",{id:"fields"},"Fields"),(0,t.yg)("h3",{id:"center-vector3--0-0-0"},(0,t.yg)("inlineCode",{parentName:"h3"},"center: Vector3 = [0, 0, 0]")),(0,t.yg)("p",null,"The center position of the box."),(0,t.yg)("h3",{id:"halfdiagonal-vector3"},(0,t.yg)("inlineCode",{parentName:"h3"},"halfDiagonal: Vector3")),(0,t.yg)("p",null,"The positive diagonal vector."),(0,t.yg)("h3",{id:"minimum-vector3"},(0,t.yg)("inlineCode",{parentName:"h3"},"minimum: Vector3")),(0,t.yg)("p",null,"The minimum corner of the bounding box."),(0,t.yg)("h3",{id:"maximum-vector3"},(0,t.yg)("inlineCode",{parentName:"h3"},"maximum: Vector3")),(0,t.yg)("p",null,"The maximum corner of the bounding box."),(0,t.yg)("h2",{id:"methods"},"Methods"),(0,t.yg)("h3",{id:"constructorminimum--0-0-0-maximum--0-0-0"},(0,t.yg)("inlineCode",{parentName:"h3"},"constructor(minimum = [0, 0, 0], maximum = [0, 0, 0])")),(0,t.yg)("h3",{id:"constructor"},(0,t.yg)("inlineCode",{parentName:"h3"},"constructor")),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"minimum=Vector3.ZERO"),": ",(0,t.yg)("inlineCode",{parentName:"li"},"Vector3")," The minimum corner of the box, i.e. ",(0,t.yg)("inlineCode",{parentName:"li"},"[xMin, yMin, zMin]"),"."),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"maximum=Vector3.ZERO"),": ",(0,t.yg)("inlineCode",{parentName:"li"},"Vector3")," The maximum corner of the box, i.e. ",(0,t.yg)("inlineCode",{parentName:"li"},"[xMax, yMax, zMax]"),".")),(0,t.yg)("h3",{id:"clone--axisalignedboundingbox"},(0,t.yg)("inlineCode",{parentName:"h3"},"clone() : AxisAlignedBoundingBox")),(0,t.yg)("p",null,"Duplicates a ",(0,t.yg)("inlineCode",{parentName:"p"},"AxisAlignedBoundingBox")," instance."),(0,t.yg)("p",null,"Returns"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"A new ",(0,t.yg)("inlineCode",{parentName:"li"},"AxisAlignedBoundingBox")," instance.")),(0,t.yg)("h3",{id:"equalsright--axisalignedboundingbox--boolean"},(0,t.yg)("inlineCode",{parentName:"h3"},"equals(right : AxisAlignedBoundingBox) : Boolean")),(0,t.yg)("p",null,"Compares the provided ",(0,t.yg)("inlineCode",{parentName:"p"},"AxisAlignedBoundingBox")," componentwise and returns ",(0,t.yg)("inlineCode",{parentName:"p"},"true")," if they are equal, ",(0,t.yg)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"right")," The second ",(0,t.yg)("inlineCode",{parentName:"li"},"AxisAlignedBoundingBox"))),(0,t.yg)("p",null,"Returns"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"true")," if left and right are equal, ",(0,t.yg)("inlineCode",{parentName:"li"},"false")," otherwise.")),(0,t.yg)("h3",{id:"intersectplaneplane--plane--intersection"},(0,t.yg)("inlineCode",{parentName:"h3"},"intersectPlane(plane : Plane) : INTERSECTION")),(0,t.yg)("p",null,"Determines which side of a plane the axis-aligned bounding box is located."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"plane")," The plane to test against.")),(0,t.yg)("p",null,"Returns"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"INTERSECTION.INSIDE")," if the entire box is on the side of the plane the normal is pointing"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"INTERSECTION.OUTSIDE")," if the entire box is on the opposite side, and"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"INTERSECTION.INTERSECTING")," if the box intersects the plane.")),(0,t.yg)("h3",{id:"distancetopoint--number3--number"},(0,t.yg)("inlineCode",{parentName:"h3"},"distanceTo(point : Number[3]) : Number")),(0,t.yg)("p",null,"Computes the estimated distance from the closest point on a bounding box to a point."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"point")," The point")),(0,t.yg)("p",null,"Returns"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"The estimated distance from the bounding sphere to the point.")),(0,t.yg)("h3",{id:"distancesquaredtopoint--number3--number"},(0,t.yg)("inlineCode",{parentName:"h3"},"distanceSquaredTo(point : Number[3]) : Number")),(0,t.yg)("p",null,"Computes the estimated distance squared from the closest point on a bounding box to a point."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"point")," The point")),(0,t.yg)("p",null,"Returns"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"The estimated distance squared from the bounding sphere to the point.")))}m.isMDXComponent=!0}}]);