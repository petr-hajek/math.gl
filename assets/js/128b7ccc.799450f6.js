"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8724],{8956:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>l});var o=i(5893),r=i(1151);const t={},s="OrientedBoundingBox",d={id:"modules/culling/api-reference/oriented-bounding-box",title:"OrientedBoundingBox",description:"An OrientedBoundingBox is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or an axis aligned bounding box in many cases.",source:"@site/../docs/modules/culling/api-reference/oriented-bounding-box.md",sourceDirName:"modules/culling/api-reference",slug:"/modules/culling/api-reference/oriented-bounding-box",permalink:"/math.gl/docs/modules/culling/api-reference/oriented-bounding-box",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/website/../docs/modules/culling/api-reference/oriented-bounding-box.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CullingVolume",permalink:"/math.gl/docs/modules/culling/api-reference/culling-volume"},next:{title:"Plane",permalink:"/math.gl/docs/modules/culling/api-reference/plane"}},c={},l=[{value:"Inheritance",id:"inheritance",level:2},{value:"Global Functions",id:"global-functions",level:2},{value:"<code>makeOrientedBoundingBoxFromPoints(positions : Array[3][], result? : OrientedBoundingBox) : OrientedBoundingBox</code>",id:"makeorientedboundingboxfrompointspositions--array3-result--orientedboundingbox--orientedboundingbox",level:3},{value:"Fields",id:"fields",level:2},{value:"<code>center: Vector3</code>",id:"center-vector3",level:3},{value:"<code>halfAxes: Matrix3</code>",id:"halfaxes-matrix3",level:3},{value:"<code>readonly halfSize: number[]</code>",id:"readonly-halfsize-number",level:3},{value:"<code>readonly quaternion: Quaternion</code>",id:"readonly-quaternion-quaternion",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0])</code>",id:"constructorcenter--0-0-0-halfaxes--0-0-0-0-0-0-0-0-0",level:3},{value:"<code>constructor</code>",id:"constructor",level:3},{value:"<code>fromCenterHalfSizeQuaternion(center : number[], halfSize : number[], </code>quaternion : number[]) : OrientedBoundingBox",id:"fromcenterhalfsizequaternioncenter--number-halfsize--number-quaternion--number--orientedboundingbox",level:3},{value:"<code>clone() : OrientedBoundingBox</code>",id:"clone--orientedboundingbox",level:3},{value:"<code>equals(right: OrientedBoundingBox) : Boolean</code>",id:"equalsright-orientedboundingbox--boolean",level:3},{value:"<code>intersectPlane(plane : Plane) : INTERSECTION</code>",id:"intersectplaneplane--plane--intersection",level:3},{value:"<code>distanceTo(point : Number[3]) : Number</code>",id:"distancetopoint--number3--number",level:3},{value:"<code>distanceSquaredTo(point : Number[3]) : Number</code>",id:"distancesquaredtopoint--number3--number",level:3},{value:"<code>computePlaneDistances(position : Number[3], direction : Number[3], result : </code>Number[2]]) : Number[2]",id:"computeplanedistancesposition--number3-direction--number3-result--number2--number2",level:3},{value:"Attribution",id:"attribution",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"orientedboundingbox",children:"OrientedBoundingBox"}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.code,{children:"OrientedBoundingBox"})," is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or an axis aligned bounding box in many cases."]}),"\n",(0,o.jsx)(n.p,{children:"The class support two representations of an oriented bounding box:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A half-axes based representation. 3 half axes vectors (",(0,o.jsx)(n.code,{children:"halfAxes: Matrix3"}),") describe size and orientation of a bounding box. This approach is used in the 3DTiles specification (",(0,o.jsx)(n.a,{href:"https://github.com/CesiumGS/3d-tiles/tree/master/specification#box",children:"https://github.com/CesiumGS/3d-tiles/tree/master/specification#box"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:["A half-size-quaternion based representation. A ",(0,o.jsx)(n.code,{children:"halfSize: number[3]"})," array describes size, a ",(0,o.jsx)(n.code,{children:"quaternion: Quaternion"})," describes orientation of a bounding box. This approach is used in the Indexed 3d Scene Layer (I3S) specification (",(0,o.jsx)(n.a,{href:"https://github.com/Esri/i3s-spec/blob/master/docs/1.7/obb.cmn.md",children:"https://github.com/Esri/i3s-spec/blob/master/docs/1.7/obb.cmn.md"}),")."]}),"\n"]}),"\n",(0,o.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,o.jsxs)(n.p,{children:["Create an ",(0,o.jsx)(n.code,{children:"OrientedBoundingBox"})," using a transformation matrix, a position where the box will be translated, and a scale."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {Vector3} from '@math.gl/core';\nimport {OrientedBoundingBox} from '@math.gl/culling';\n\nconst center = new Vector3(1.0, 0.0, 0.0);\nconst halfAxes = new Matrix3().fromScale([1.0, 3.0, 2.0]);\nconst box = new OrientedBoundingBox(center, halfAxes);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Sort bounding boxes from back to front"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"boxes.sort(\n  (boxA, boxB) =>\n    boxB.distanceSquaredTo(camera.positionWC) - boxA.distanceSquaredTo(camera.positionWC)\n);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Compute an oriented bounding box enclosing two points."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {makeOrientedBoundingBoxFromPoints} from '@math.gl/culling';\n\nconst box = makeOrientedBoundingBoxFromPoints([\n  [2, 0, 0],\n  [-2, 0, 0]\n]);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"class OrientedBoundingBox implements"})," ",(0,o.jsx)(n.a,{href:"./bounding-volume",children:(0,o.jsx)(n.code,{children:"BoundingVolume"})}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"global-functions",children:"Global Functions"}),"\n",(0,o.jsx)(n.h3,{id:"makeorientedboundingboxfrompointspositions--array3-result--orientedboundingbox--orientedboundingbox",children:(0,o.jsx)(n.code,{children:"makeOrientedBoundingBoxFromPoints(positions : Array[3][], result? : OrientedBoundingBox) : OrientedBoundingBox"})}),"\n",(0,o.jsxs)(n.p,{children:["Computes an instance of an ",(0,o.jsx)(n.code,{children:"OrientedBoundingBox"})," of the given positions.\nThis is an implementation of Stefan Gottschalk's ",(0,o.jsx)(n.a,{href:"http://gamma.cs.unc.edu/users/gottschalk/main.pdf",children:"Collision Queries using Oriented Bounding Boxes"})," (PHD thesis)."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"positions"})," List of ",(0,o.jsx)(n.code,{children:"Vector3"})," points that the bounding box will enclose."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"result"})," Optional object onto which to store the result."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,o.jsx)(n.h3,{id:"center-vector3",children:(0,o.jsx)(n.code,{children:"center: Vector3"})}),"\n",(0,o.jsx)(n.p,{children:"The center position of the box."}),"\n",(0,o.jsx)(n.h3,{id:"halfaxes-matrix3",children:(0,o.jsx)(n.code,{children:"halfAxes: Matrix3"})}),"\n",(0,o.jsx)(n.p,{children:"The transformation matrix, to rotate the box to the right position."}),"\n",(0,o.jsx)(n.h3,{id:"readonly-halfsize-number",children:(0,o.jsx)(n.code,{children:"readonly halfSize: number[]"})}),"\n",(0,o.jsx)(n.p,{children:"The array with three half-sizes for the bounding box"}),"\n",(0,o.jsx)(n.h3,{id:"readonly-quaternion-quaternion",children:(0,o.jsx)(n.code,{children:"readonly quaternion: Quaternion"})}),"\n",(0,o.jsx)(n.p,{children:"The quaternion describing the orientation of the bounding box"}),"\n",(0,o.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(n.h3,{id:"constructorcenter--0-0-0-halfaxes--0-0-0-0-0-0-0-0-0",children:(0,o.jsx)(n.code,{children:"constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0])"})}),"\n",(0,o.jsx)(n.h3,{id:"constructor",children:(0,o.jsx)(n.code,{children:"constructor"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"center"}),"=",(0,o.jsx)(n.code,{children:"Vector3.ZERO"})," The center of the box."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"halfAxes"}),"=",(0,o.jsx)(n.code,{children:"Matrix3.ZERO"})," The three orthogonal half-axes of the bounding box. Equivalently, the transformation matrix, to rotate and scale a cube centered at the origin."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"fromcenterhalfsizequaternioncenter--number-halfsize--number-quaternion--number--orientedboundingbox",children:[(0,o.jsx)(n.code,{children:"fromCenterHalfSizeQuaternion(center : number[], halfSize : number[], "}),"quaternion : number[]) : OrientedBoundingBox"]}),"\n",(0,o.jsx)(n.p,{children:"Create an OrientedBoundingBox from a half-size-quaternion based OBB"}),"\n",(0,o.jsx)(n.h3,{id:"clone--orientedboundingbox",children:(0,o.jsx)(n.code,{children:"clone() : OrientedBoundingBox"})}),"\n",(0,o.jsx)(n.p,{children:"Duplicates a OrientedBoundingBox instance."}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A new ",(0,o.jsx)(n.code,{children:"OrientedBoundingBox"})," instance."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"equalsright-orientedboundingbox--boolean",children:(0,o.jsx)(n.code,{children:"equals(right: OrientedBoundingBox) : Boolean"})}),"\n",(0,o.jsxs)(n.p,{children:["Compares the provided OrientedBoundingBox componentwise and returns ",(0,o.jsx)(n.code,{children:"true"})," if they are equal, ",(0,o.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"right"})," The second ",(0,o.jsx)(n.code,{children:"OrientedBoundingBox"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"true"})," if left and right are equal, ",(0,o.jsx)(n.code,{children:"false"})," otherwise."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"intersectplaneplane--plane--intersection",children:(0,o.jsx)(n.code,{children:"intersectPlane(plane : Plane) : INTERSECTION"})}),"\n",(0,o.jsx)(n.p,{children:"Determines which side of a plane the oriented bounding box is located."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"plane"})," The plane to test against."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"INTERSECTION.INSIDE"})," if the entire box is on the side of the plane the normal is pointing"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"INTERSECTION.OUTSIDE"})," if the entire box is on the opposite side, and"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"INTERSECTION.INTERSECTING"})," if the box intersects the plane."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"distancetopoint--number3--number",children:(0,o.jsx)(n.code,{children:"distanceTo(point : Number[3]) : Number"})}),"\n",(0,o.jsx)(n.p,{children:"Computes the estimated distance from the closest point on a bounding box to a point."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"point"})," The point"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The estimated distance from the bounding sphere to the point."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"distancesquaredtopoint--number3--number",children:(0,o.jsx)(n.code,{children:"distanceSquaredTo(point : Number[3]) : Number"})}),"\n",(0,o.jsx)(n.p,{children:"Computes the estimated distance squared from the closest point on a bounding box to a point."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"point"})," The point"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The estimated distance squared from the bounding sphere to the point."}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"computeplanedistancesposition--number3-direction--number3-result--number2--number2",children:[(0,o.jsx)(n.code,{children:"computePlaneDistances(position : Number[3], direction : Number[3], result : "}),"Number[2]]) : Number[2]"]}),"\n",(0,o.jsx)(n.p,{children:"The distances calculated by the vector from the center of the bounding box to position projected onto direction."}),"\n",(0,o.jsx)(n.p,{children:"If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the closest and farthest planes from position that intersect the bounding box."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"position"})," The position to calculate the distance from."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"direction"})," The direction from position."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"result"})," An optional Interval to store the nearest and farthest distances."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The nearest and farthest distances on the bounding box from position in direction."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"attribution",children:"Attribution"}),"\n",(0,o.jsxs)(n.p,{children:["This class was ported from ",(0,o.jsx)(n.a,{href:"https://github.com/AnalyticalGraphicsInc/cesium",children:"Cesium"})," under the Apache 2 License."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>s});var o=i(7294);const r={},t=o.createContext(r);function s(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);