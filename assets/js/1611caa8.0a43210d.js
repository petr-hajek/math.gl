"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[327],{4192:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=o(4848),t=o(8453);const r={},l="Polygon",s={id:"modules/polygon/api-reference/polygon",title:"Polygon",description:"Allows an array of points (whether closed or non-closed) to be treated as a Polygon.",source:"@site/../docs/modules/polygon/api-reference/polygon.md",sourceDirName:"modules/polygon/api-reference",slug:"/modules/polygon/api-reference/polygon",permalink:"/math.gl/docs/modules/polygon/api-reference/polygon",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/polygon/api-reference/polygon.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"cutPolylineByMercatorBounds",permalink:"/math.gl/docs/modules/polygon/api-reference/cut-polyline-by-mercator-bounds"},next:{title:"Overview",permalink:"/math.gl/docs/modules/proj4/"}},d={},c=[{value:"Usage",id:"usage",level:2},{value:"Methods",id:"methods",level:2},{value:"constructor",id:"constructor",level:3},{value:"getSignedArea",id:"getsignedarea",level:3},{value:"getArea",id:"getarea",level:3},{value:"getWindingDirection",id:"getwindingdirection",level:3},{value:"forEachSegment",id:"foreachsegment",level:3},{value:"modifyWindingDirection",id:"modifywindingdirection",level:3},{value:"Remarks",id:"remarks",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"polygon",children:"Polygon"})}),"\n",(0,i.jsx)(n.p,{children:"Allows an array of points (whether closed or non-closed) to be treated as a Polygon."}),"\n",(0,i.jsxs)(n.p,{children:["Implements the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Shoelace_formula",children:"Shoelace formula"})," for determining the area and winding direction of an arbitrary polygon."]}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import {Polygon} from '@math.gl/polygon';\n"})}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"constructor",children:"constructor"}),"\n",(0,i.jsx)(n.p,{children:"Creates a new Polygon object."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The polygon object will reference the provided points, assuming them to not be modified for the lifetime of the Polygon object."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"getsignedarea",children:"getSignedArea"}),"\n",(0,i.jsx)(n.p,{children:"Returns the area with a sign indicating the winding direction."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"polygon.getSignedArea()"})}),"\n",(0,i.jsx)(n.h3,{id:"getarea",children:"getArea"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"polygon.getArea()"})}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A convenience method that returns ",(0,i.jsx)(n.code,{children:"Math.abs(polygon.getSignedArea())"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"getwindingdirection",children:"getWindingDirection"}),"\n",(0,i.jsx)(n.p,{children:"Returns the direction of the polygon path."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"polygon.getWindingDirection()"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A positive number is clockwise."}),"\n",(0,i.jsx)(n.li,{children:"A negative number is counter clockwise."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Note:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A convenience method that returns ",(0,i.jsx)(n.code,{children:"Math.sign(polygon.getSignedArea())"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"foreachsegment",children:"forEachSegment"}),"\n",(0,i.jsx)(n.p,{children:"Lets the application iterate over each segment."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"polygon.forEachSegment((p1, p2) => ...);"})}),"\n",(0,i.jsx)(n.h3,{id:"modifywindingdirection",children:"modifyWindingDirection"}),"\n",(0,i.jsx)(n.p,{children:"Checks winding direction of the polygon and reverses the polygon in case if opposite winding direction. Note: points of the polygon are modified in-place."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A positive number is clockwise."}),"\n",(0,i.jsx)(n.li,{children:"A negative number is counter clockwise."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"polygon.modifyWindingDirection(direction);"})}),"\n",(0,i.jsx)(n.p,{children:"Returns:"}),"\n",(0,i.jsx)(n.p,{children:"Returns true if the winding direction was changed."}),"\n",(0,i.jsx)(n.h2,{id:"remarks",children:"Remarks"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["To avoid having to copy a non-closed path to be able to treat it as a polygon (by adding a copy of the first vertex to then end of the path),\ninstead we define a ",(0,i.jsx)(n.code,{children:"forEachSegment"})," iteration method that makes sure the last segment is iterated over."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>s});var i=o(6540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);