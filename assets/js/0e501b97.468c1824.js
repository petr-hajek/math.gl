"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5372],{1260:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(5893),o=n(1151);const a={},s="Transformations",i={id:"developer-guide/math/transformations",title:"Transformations",description:"math.gl allows you to create mathematical objects and then apply transformations on those objects. Objects are typically vectors but can also be more complex object such as spheres, planes, boxes etc, and transformations are typically represented by matrices and quaternions.",source:"@site/../docs/developer-guide/math/transformations.md",sourceDirName:"developer-guide/math",slug:"/developer-guide/math/transformations",permalink:"/math.gl/docs/developer-guide/math/transformations",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/website/../docs/developer-guide/math/transformations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Discrete Global Grids",permalink:"/math.gl/docs/developer-guide/geospatial/dggs"},next:{title:"View and Projection Matrices",permalink:"/math.gl/docs/developer-guide/math/view-and-projection"}},c={},l=[{value:"Representing Transformations",id:"representing-transformations",level:2},{value:"Applying transformations",id:"applying-transformations",level:2},{value:"Types of Transformations",id:"types-of-transformations",level:2},{value:"Composing Transformations",id:"composing-transformations",level:2},{value:"Order Matters",id:"order-matters",level:2},{value:"About Rotations",id:"about-rotations",level:2},{value:"Decomposing Transformations",id:"decomposing-transformations",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"transformations",children:"Transformations"}),"\n",(0,r.jsx)(t.p,{children:"math.gl allows you to create mathematical objects and then apply transformations on those objects. Objects are typically vectors but can also be more complex object such as spheres, planes, boxes etc, and transformations are typically represented by matrices and quaternions."}),"\n",(0,r.jsx)(t.h2,{id:"representing-transformations",children:"Representing Transformations"}),"\n",(0,r.jsx)(t.p,{children:"Transformations can be represented in many different notations but for computational purposes it is efficient to express them as matrices, or in some cases as quaternions."}),"\n",(0,r.jsxs)(t.p,{children:["The most general transform is a 4x4 matrix. See the article on ",(0,r.jsx)(t.a,{href:"/math.gl/docs/developer-guide/math/homogeneous-coordinates",children:"homogeneous coordinates"})," for some advantages in using 4x4 matrices to represent transformations."]}),"\n",(0,r.jsx)(t.h2,{id:"applying-transformations",children:"Applying transformations"}),"\n",(0,r.jsxs)(t.p,{children:["Most math.gl classes offer a ",(0,r.jsx)(t.code,{children:"transform"})," method that accepts matrices and quaternions."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"// prettier-ignore\nconst transformedVector1 = new Vector4(1, 0, 0, 1).transform([\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n]);\n// or\nconst transformedVector2 = new Vector4(1, 0, 0, 1).transform(\n  new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n);\n"})}),"\n",(0,r.jsx)(t.p,{children:"The various vector classes also offer methods to transform with smaller matrices"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const transformedVector1 = new Vector4(1, 0, 0, 1).transformByMatrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n// or\nconst transformedVector2 = new Vector3(1, 0, 0).transformByMatrix2(new Matrix2([1, 0, 0, 1]));\n"})}),"\n",(0,r.jsx)(t.p,{children:"Quaternion transformations are also supported on some objects"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const transformedVector1 = new Vector4(1, 0, 0).transformByQuaternion([0, 0, 0, 1]);\n// or\nconst transformedVector2 = new Vector3(1, 0, 0).transformByQuaternion(new Quaternion([1, 0, 0, 1]));\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Note that ",(0,r.jsx)(t.code,{children:"<object>.transform()"}),' operations modify the object being transformed (and also return the modified object to enable "chaining" of calls).']}),"\n",(0,r.jsxs)(t.p,{children:["Alternatively, transformations can also be performed via the matrix and quaternion classes. In this case, the transformation is stored in the result parameters (a new array is allocated if it ",(0,r.jsx)(t.code,{children:"result"})," is not supplied.)"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const transformedVector1 = new Vector4(1, 0, 0).transformByQuaternion([0, 0, 0, 1]);\n// or\nconst result = new Vector3();\nconst transformedVector2 = new Quaternion([1, 0, 0, 1]).transformByQuaternion([1, 0, 0], result);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"types-of-transformations",children:"Types of Transformations"}),"\n",(0,r.jsx)(t.p,{children:"The basic transformations are rotations, scalings, and translations."}),"\n",(0,r.jsx)(t.h2,{id:"composing-transformations",children:"Composing Transformations"}),"\n",(0,r.jsx)(t.p,{children:"One of the most powerful aspects of using matrices to manage transformations is that matrices can be multiplied together using linear algebra."}),"\n",(0,r.jsx)(t.p,{children:"This allows us to build up a complex transformation by multiplying together component parts."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Matrix4"})," provides a number of transformation methods ('scale', 'rotate', 'translate', ...) that allow us to build transformation matrices. These can be applied to an identity matrix (e.g. a newly created ",(0,r.jsx)(t.code,{children:"Matrix4"}),") or to a matrix that already contains other transformations."]}),"\n",(0,r.jsx)(t.h2,{id:"order-matters",children:"Order Matters"}),"\n",(0,r.jsx)(t.p,{children:"When composing (i.e. multiplying) matrices it is critical to consider the order in which they are being applied, as changing the order of component will in most cases change the resulting composite transformation. It is not hard to verify that this is consistent with geometric intuition by composing a few operations on paper."}),"\n",(0,r.jsxs)(t.p,{children:["Because of this the ",(0,r.jsx)(t.code,{children:"Matrix4"})," class provides two matrix multiplication methods: ",(0,r.jsx)(t.code,{children:"multiplyLeft"})," and ",(0,r.jsx)(t.code,{children:"multiplyRight"})," that force you to make explicit what you intend when multiplying two matrices."]}),"\n",(0,r.jsxs)(t.p,{children:["All ",(0,r.jsx)(t.code,{children:"Matrix4"})," transformation methods ('scale', 'rotate', 'translate', ...) conceptually correspond to multiplying in a new transformation matrix from the right (although these methods internally are more efficient in that they don't create any temporary objects and they only do the minimal amount of changes to the matrix required for that specific transformation)."]}),"\n",(0,r.jsxs)(t.p,{children:["In the end, the point or vector to be transformed will be multiplied in from the right, which means that a typical composed transformation needs to be read in reverse order. I.e. in the example below, the vector will first be rotated, then transformed by the ",(0,r.jsx)(t.code,{children:"partialTransform"}),", then scaled."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"// Illustrates that transformations are applied in reverse order\nconst partialTransform = new Matrix4(...);\nconst fullTransform = new Matrix4()\n  .scale([1, -1, 1])\n  .multiplyRight(partialTransform)\n  .rotateX({radians: Math.PI});\nconst v = fullTransform.transformVector(new Vector4(...));\n"})}),"\n",(0,r.jsx)(t.h2,{id:"about-rotations",children:"About Rotations"}),"\n",(0,r.jsxs)(t.p,{children:["For more in-depth background about rotations, see the separate article on ",(0,r.jsx)(t.a,{href:"/math.gl/docs/developer-guide/math/rotations",children:"rotations"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"If you have a vector with 3 elements you can rotate it around an axis and a point like so:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const v = new Vector3([1, 2, 3]).rotateZ({radians: ..., origin: [1, 1, 0]});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"decomposing-transformations",children:"Decomposing Transformations"}),"\n",(0,r.jsxs)(t.p,{children:["The ability to compose transformations naturally leads to the possibility of ",(0,r.jsx)(t.em,{children:"decomposing"})," a composite transformations into its constituent parts. This is possible, with certain caveats (not all matrices are directly decomposable into rotation, translation and scale. Shear is currently not handled)."]}),"\n",(0,r.jsxs)(t.p,{children:["Sepcifically, the math.gl ",(0,r.jsx)(t.code,{children:"Matrix4"})," object exposes the ",(0,r.jsx)(t.code,{children:"getScale"}),", ",(0,r.jsx)(t.code,{children:"getTranslation"})," and ",(0,r.jsx)(t.code,{children:"getRotation"})," (or ",(0,r.jsx)(t.code,{children:"getRotationMatrix3"}),") methods are provided for this purpose:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const transform = new Matrix4()\n  .translate([10, 10, 0])\n  .rotateX(Math.PI / 4)\n  .scale(5);\ntransform.getScale(); // [5, 5, 5]\ntransform.getTranslation(); // [ 10, 10, 0]\n"})})]})}function m(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var r=n(7294);const o={},a=r.createContext(o);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);