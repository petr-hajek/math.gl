"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8733],{5990:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var r=i(4848),l=i(8453);const t={},s="Plane",o={id:"modules/culling/api-reference/plane",title:"Plane",description:"A plane in Hessian Normal Form defined by ax + by + cz + d = 0 where [a, b, c] is the plane's normal, d is the signed distance to the plane (from the origin along the normal), and [x, y, z] is any point on the plane.",source:"@site/../docs/modules/culling/api-reference/plane.md",sourceDirName:"modules/culling/api-reference",slug:"/modules/culling/api-reference/plane",permalink:"/math.gl/docs/modules/culling/api-reference/plane",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/culling/api-reference/plane.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"OrientedBoundingBox",permalink:"/math.gl/docs/modules/culling/api-reference/oriented-bounding-box"},next:{title:"Overview",permalink:"/math.gl/docs/modules/geoid/"}},a={},c=[{value:"Usage",id:"usage",level:2},{value:"Fields",id:"fields",level:2},{value:"normal : Vector3",id:"normal--vector3",level:3},{value:"distance : Number",id:"distance--number",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor(normal : Number[3], distance : Number)",id:"constructornormal--number3-distance--number",level:3},{value:"fromPointNormal(point : Number[3], normal : Number[3]) : Plane",id:"frompointnormalpoint--number3-normal--number3--plane",level:3},{value:"Plane.fromCoefficients(coefficients : Number[4]) : Plane",id:"planefromcoefficientscoefficients--number4--plane",level:3},{value:"clone() : Plane",id:"clone--plane",level:3},{value:"equals(right : Plane) : Boolean",id:"equalsright--plane--boolean",level:3},{value:"getPointDistance(point : Number[3]) : Number",id:"getpointdistancepoint--number3--number",level:3},{value:"projectPointOntoPlane(point : Number[3], result : Number[3]]) : Number[3]",id:"projectpointontoplanepoint--number3-result--number3--number3",level:3},{value:"transform(transform : Number[16]) : Plane",id:"transformtransform--number16--plane",level:3},{value:"Attribution",id:"attribution",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"plane",children:"Plane"})}),"\n",(0,r.jsxs)(n.p,{children:["A plane in Hessian Normal Form defined by ",(0,r.jsx)(n.code,{children:"ax + by + cz + d = 0"})," where ",(0,r.jsx)(n.code,{children:"[a, b, c]"})," is the plane's ",(0,r.jsx)(n.code,{children:"normal"}),", ",(0,r.jsx)(n.code,{children:"d"})," is the signed distance to the plane (from the origin along the normal), and ",(0,r.jsx)(n.code,{children:"[x, y, z]"})," is any point on the plane."]}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["Create the plane ",(0,r.jsx)(n.code,{children:"x=0"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Plane} from '@math.gl/culling';\nconst plane = new Plane([1, 0, 0], 0.0);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Create a tangent plane for a cartographic coordinate"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst point = [-72.0, 40.0, 0];\nconst normal = Ellipsoid.WGS84.geodeticSurfaceNormal([-72.0, 40.0]);\nconst tangentPlane = new Plane().fromPointNormal(point, normal);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,r.jsx)(n.h3,{id:"normal--vector3",children:"normal : Vector3"}),"\n",(0,r.jsx)(n.p,{children:"The plane's normal."}),"\n",(0,r.jsx)(n.h3,{id:"distance--number",children:"distance : Number"}),"\n",(0,r.jsxs)(n.p,{children:["The shortest distance from the origin to the plane. The sign of ",(0,r.jsx)(n.code,{children:"distance"})," determines which side of the plane the origin is on. If ",(0,r.jsx)(n.code,{children:"distance"})," is positive, the origin is in the half-space in the direction of the normal; if negative, the origin is in the half-space opposite to the normal; if zero, the plane passes through the origin."]}),"\n",(0,r.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(n.h3,{id:"constructornormal--number3-distance--number",children:"constructor(normal : Number[3], distance : Number)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Vector3"})," normal The plane's normal (normalized)."]}),"\n",(0,r.jsxs)(n.li,{children:["Number distance The shortest distance from the origin to the plane. The sign of ",(0,r.jsx)(n.code,{children:"distance"})," determines which side of the plane the origin is on. If ",(0,r.jsx)(n.code,{children:"distance"})," is positive, the origin is in the half-space in the direction of the normal; if negative, the origin is in the half-space opposite to the normal; if zero, the plane passes through the origin."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Throws"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Normal must be normalized"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"frompointnormalpoint--number3-normal--number3--plane",children:"fromPointNormal(point : Number[3], normal : Number[3]) : Plane"}),"\n",(0,r.jsx)(n.p,{children:"Creates a plane from a normal and a point on the plane."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Vector3"})," point The point on the plane."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Vector3"})," normal The plane's normal (normalized)."]}),"\n",(0,r.jsx)(n.li,{children:"Plane [result] The object onto which to store the result."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Throws"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Normal must be normalized"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"planefromcoefficientscoefficients--number4--plane",children:"Plane.fromCoefficients(coefficients : Number[4]) : Plane"}),"\n",(0,r.jsx)(n.p,{children:"Creates a plane from the general equation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"coefficients"})," The plane coefficients (normalized)."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Throws"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Normal must be normalized"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"clone--plane",children:"clone() : Plane"}),"\n",(0,r.jsx)(n.p,{children:"Duplicates a Plane instance."}),"\n",(0,r.jsx)(n.p,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A new Plane instance with the same values"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"equalsright--plane--boolean",children:"equals(right : Plane) : Boolean"}),"\n",(0,r.jsxs)(n.p,{children:["Compares the provided Planes by normal and distance and returns ",(0,r.jsx)(n.code,{children:"true"})," if they are equal, ",(0,r.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"right"})," The second plane."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"true"})," if left and right are equal, ",(0,r.jsx)(n.code,{children:"false"})," otherwise."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"getpointdistancepoint--number3--number",children:"getPointDistance(point : Number[3]) : Number"}),"\n",(0,r.jsx)(n.p,{children:"Computes the signed shortest distance of a point to a plane. The sign of the distance determines which side of the plane the point is on. If the distance is positive, the point is in the half-space in the direction of the normal; if negative, the point is in the half-space opposite to the normal; if zero, the plane passes through the point."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"point"})," The point."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Number The signed shortest distance of the point to the plane."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"projectpointontoplanepoint--number3-result--number3--number3",children:"projectPointOntoPlane(point : Number[3], result : Number[3]]) : Number[3]"}),"\n",(0,r.jsx)(n.p,{children:"Projects a point onto the plane."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"point"})," The point to project onto the plane"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"result"})," The result point. If undefined, a new ",(0,r.jsx)(n.code,{children:"Array"})," will be created."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The modified result parameter or a new ",(0,r.jsx)(n.code,{children:"Vector3"})," instance if one was not provided."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"transformtransform--number16--plane",children:"transform(transform : Number[16]) : Plane"}),"\n",(0,r.jsx)(n.p,{children:"Transforms the plane by the given transformation matrix."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Matrix4 transform The transformation matrix."}),"\n",(0,r.jsx)(n.li,{children:"Plane [result] The object into which to store the result."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Plane The plane transformed by the given transformation matrix."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"attribution",children:"Attribution"}),"\n",(0,r.jsxs)(n.p,{children:["This class was ported from ",(0,r.jsx)(n.a,{href:"https://github.com/AnalyticalGraphicsInc/cesium",children:"Cesium"})," under the Apache 2 License."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const l={},t=r.createContext(l);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);