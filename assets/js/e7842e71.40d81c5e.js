"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[3552],{3323:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>x,frontMatter:()=>t,metadata:()=>c,toc:()=>l});var r=d(4848),i=d(8453);const t={},s="WebMercatorViewport",c={id:"modules/web-mercator/api-reference/web-mercator-viewport",title:"WebMercatorViewport",description:"The WebMercatorViewport class takes map camera states (latitude, longitude, zoom, pitch, bearing etc.),",source:"@site/../docs/modules/web-mercator/api-reference/web-mercator-viewport.md",sourceDirName:"modules/web-mercator/api-reference",slug:"/modules/web-mercator/api-reference/web-mercator-viewport",permalink:"/math.gl/docs/modules/web-mercator/api-reference/web-mercator-viewport",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/web-mercator/api-reference/web-mercator-viewport.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Web Mercator Utility Functions",permalink:"/math.gl/docs/modules/web-mercator/api-reference/web-mercator-utils"},next:{title:"Overview",permalink:"/math.gl/docs/modules/dggs-geohash/"}},o={},l=[{value:"Constructor",id:"constructor",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>project(lngLatZ, options)</code>",id:"projectlnglatz-options",level:5},{value:"<code>unproject(xyz, options)</code>",id:"unprojectxyz-options",level:5},{value:"<code>projectFlat(lngLat, scale)</code>",id:"projectflatlnglat-scale",level:5},{value:"<code>unprojectFlat(xy, scale)</code>",id:"unprojectflatxy-scale",level:5},{value:"<code>getBounds(options)</code>",id:"getboundsoptions",level:5},{value:"<code>getBoundingRegion(options)</code>",id:"getboundingregionoptions",level:5},{value:"<code>fitBounds(bounds, options: object)</code>",id:"fitboundsbounds-options-object",level:5},{value:"<code>getMapCenterByLngLatPosition(options: object): [number, number]</code>",id:"getmapcenterbylnglatpositionoptions-object-number-number",level:5}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h5:"h5",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"webmercatorviewport",children:"WebMercatorViewport"})}),"\n",(0,r.jsx)("p",{class:"badges",children:(0,r.jsx)("img",{src:"https://img.shields.io/badge/From-v3.1-blue.svg?style=flat-square",alt:"From-v3.1"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"WebMercatorViewport"})," class takes map camera states (",(0,r.jsx)(n.code,{children:"latitude"}),", ",(0,r.jsx)(n.code,{children:"longitude"}),", ",(0,r.jsx)(n.code,{children:"zoom"}),", ",(0,r.jsx)(n.code,{children:"pitch"}),", ",(0,r.jsx)(n.code,{children:"bearing"})," etc.),\nand performs projections between world and screen coordinates."]}),"\n",(0,r.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"width"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"1"})}),(0,r.jsx)(n.td,{children:"Width of viewport"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"height"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"1"})}),(0,r.jsx)(n.td,{children:"Height of viewport"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"latitude"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0"})}),(0,r.jsx)(n.td,{children:"Latitude of viewport center"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"longitude"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0"})}),(0,r.jsx)(n.td,{children:"Longitude of viewport center"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"zoom"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"11"})}),(0,r.jsxs)(n.td,{children:["Map zoom (scale is calculated as ",(0,r.jsx)(n.code,{children:"2^zoom"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"pitch"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0"})}),(0,r.jsx)(n.td,{children:"The pitch (tilt) of the map from the screen, in degrees (0 is straight down)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bearing"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0"})}),(0,r.jsx)(n.td,{children:"The bearing (rotation) of the map from north, in degrees counter-clockwise (0 means north is up)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fovy"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"see below"})}),(0,r.jsx)(n.td,{children:"Field of view of camera in degrees"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"altitude"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"see below"})}),(0,r.jsx)(n.td,{children:"Altitude of camera in screen units"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"position"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number[]"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"null"})}),(0,r.jsx)(n.td,{children:"Offset of the camera, in meters"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Remarks:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If either ",(0,r.jsx)(n.code,{children:"altitude"})," or ",(0,r.jsx)(n.code,{children:"fovy"})," is not provided, the missing value is computed from the other using ",(0,r.jsx)(n.code,{children:"altitudeToFovy()"}),"/",(0,r.jsx)(n.code,{children:"fovyToAltitude()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Altitude has a default value that matches assumptions in mapbox-gl. It is only used if both ",(0,r.jsx)(n.code,{children:"altitude"})," and ",(0,r.jsx)(n.code,{children:"fovy"})," are not supplied."]}),"\n",(0,r.jsxs)(n.li,{children:["Field of view is independent from altitude, provide ",(0,r.jsx)(n.code,{children:"altitudeToFovy(1.5)"})," (default value) to match assumptions in mapbox-gl"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"width"})," and ",(0,r.jsx)(n.code,{children:"height"})," are forced to 1 if supplied as 0, to avoid\ndivision by zero. This is intended to reduce the burden of apps to\nto check values before instantiating a ",(0,r.jsx)(n.code,{children:"Viewport"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"When using Mercator projection, per cartographic tradition, longitudes and\nlatitudes are specified as degrees."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(n.h5,{id:"projectlnglatz-options",children:(0,r.jsx)(n.code,{children:"project(lngLatZ, options)"})}),"\n",(0,r.jsx)(n.p,{children:"Projects latitude and longitude to pixel coordinates on screen."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"lngLatZ"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Array"})}),(0,r.jsx)(n.td,{children:"(required)"}),(0,r.jsxs)(n.td,{children:["map coordinates, ",(0,r.jsx)(n.code,{children:"[lng, lat]"})," or ",(0,r.jsx)(n.code,{children:"[lng, lat, Z]"})," where ",(0,r.jsx)(n.code,{children:"Z"})," is elevation in meters"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"options"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Object"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{}"})}),(0,r.jsx)(n.td,{children:"named options"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"options.topLeft"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Boolean"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsxs)(n.td,{children:["If ",(0,r.jsx)(n.code,{children:"true"})," projected coords are top left, otherwise bottom left"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Returns: ",(0,r.jsx)(n.code,{children:"[x, y]"})," or ",(0,r.jsx)(n.code,{children:"[x, y, z]"})," in pixels coordinates. ",(0,r.jsx)(n.code,{children:"z"})," is pixel depth."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If input is ",(0,r.jsx)(n.code,{children:"[lng, lat]"}),": returns ",(0,r.jsx)(n.code,{children:"[x, y]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If input is ",(0,r.jsx)(n.code,{children:"[lng, lat, Z]"}),": returns ",(0,r.jsx)(n.code,{children:"[x, y, z]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Remarks:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"By default, returns top-left coordinates suitable for canvas/SVG type\nrendering."}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"unprojectxyz-options",children:(0,r.jsx)(n.code,{children:"unproject(xyz, options)"})}),"\n",(0,r.jsx)(n.p,{children:"Unproject pixel coordinates on screen to longitude and latitude on map."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"xyz"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Array"})}),(0,r.jsx)(n.td,{children:"(required)"}),(0,r.jsxs)(n.td,{children:["pixel coordinates, ",(0,r.jsx)(n.code,{children:"[x, y]"})," or ",(0,r.jsx)(n.code,{children:"[x, y, z]"})," where ",(0,r.jsx)(n.code,{children:"z"})," is pixel depth"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"options"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Object"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{}"})}),(0,r.jsx)(n.td,{children:"named options"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"options.topLeft"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Boolean"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsxs)(n.td,{children:["If ",(0,r.jsx)(n.code,{children:"true"})," projected coords are top left, otherwise bottom left"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"options.targetZ"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0"})}),(0,r.jsxs)(n.td,{children:["If pixel depth ",(0,r.jsx)(n.code,{children:"z"})," is not specified in ",(0,r.jsx)(n.code,{children:"xyz"}),", use ",(0,r.jsx)(n.code,{children:"options.targetZ"})," as the desired elevation"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Returns: ",(0,r.jsx)(n.code,{children:"[lng, lat]"})," or ",(0,r.jsx)(n.code,{children:"[longitude, lat, Z]"})," in map coordinates. ",(0,r.jsx)(n.code,{children:"Z"})," is elevation in meters."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If input is ",(0,r.jsx)(n.code,{children:"[x, y]"})," without specifying ",(0,r.jsx)(n.code,{children:"options.targetZ"}),": returns ",(0,r.jsx)(n.code,{children:"[lng, lat]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If input is ",(0,r.jsx)(n.code,{children:"[x, y]"})," with ",(0,r.jsx)(n.code,{children:"options.targetZ"}),": returns ",(0,r.jsx)(n.code,{children:"[lng, lat, targetZ]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If input is ",(0,r.jsx)(n.code,{children:"[x, y, z]"}),": returns ",(0,r.jsx)(n.code,{children:"[lng, lat, Z]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"projectflatlnglat-scale",children:(0,r.jsx)(n.code,{children:"projectFlat(lngLat, scale)"})}),"\n",(0,r.jsx)(n.p,{children:"Project longitude and latitude onto Web Mercator coordinates."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"lngLat"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Array"})}),(0,r.jsx)(n.td,{children:"(required)"}),(0,r.jsxs)(n.td,{children:["map coordinates, ",(0,r.jsx)(n.code,{children:"[lng, lat]"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"scale"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"this.scale"})}),(0,r.jsx)(n.td,{children:"Web Mercator scale"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Returns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[x, y]"}),", representing Web Mercator coordinates."]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"unprojectflatxy-scale",children:(0,r.jsx)(n.code,{children:"unprojectFlat(xy, scale)"})}),"\n",(0,r.jsx)(n.p,{children:"Unprojects a Web Mercator coordinate to longitude and latitude."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"xy"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Array"})}),(0,r.jsx)(n.td,{children:"(required)"}),(0,r.jsxs)(n.td,{children:["Web Mercator coordinates, ",(0,r.jsx)(n.code,{children:"[x, y]"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"scale"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"this.scale"})}),(0,r.jsx)(n.td,{children:"Web Mercator scale"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Returns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"[longitude, latitude]"})}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"getboundsoptions",children:(0,r.jsx)(n.code,{children:"getBounds(options)"})}),"\n",(0,r.jsx)(n.p,{children:"Get the axis-aligned bounding box of the current visible area."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options.z"})," (number, optional) - To calculate a bounding volume for fetching 3D data, this option can be used to get the bounding box at a specific elevation. Default ",(0,r.jsx)(n.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[[lon, lat], [lon, lat]]"})," as the south west and north east corners of the smallest orthogonal bounds that encompasses the visible region."]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"getboundingregionoptions",children:(0,r.jsx)(n.code,{children:"getBoundingRegion(options)"})}),"\n",(0,r.jsx)(n.p,{children:"Get the vertices of the current visible region."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options.z"})," (number, optional) - To calculate a bounding volume for fetching 3D data, this option can be used to get the bounding region at a specific elevation. Default ",(0,r.jsx)(n.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An array of 4 corners in ",(0,r.jsx)(n.code,{children:"[longitude, latitude, altitude]"})," that define the visible region."]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"fitboundsbounds-options-object",children:(0,r.jsx)(n.code,{children:"fitBounds(bounds, options: object)"})}),"\n",(0,r.jsx)(n.p,{children:"Get a new flat viewport that fits around the given bounding box."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bounds"})," ([[number,number],[number,number]]) - an array of two opposite corners of\nthe bounding box. Each corner is specified in ",(0,r.jsx)(n.code,{children:"[lon, lat]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options.padding"})," (",(0,r.jsx)(n.code,{children:"number|{top:number, bottom: number, left: number, right: number}, optional"}),") - The amount of\npadding in pixels to add to the given bounds from the edge of the viewport. If padding is set as object, all parameters are\nrequired."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options.offset"})," ([number,number], optional) - The center of the given bounds relative to the viewport's center, ",(0,r.jsx)(n.code,{children:"[x, y]"})," measured in pixels."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"opts.minExtent"})," (number, optional) - If supplied, the bounds used to calculate the new map settings will be expanded if the delta width or height of the supplied ",(0,r.jsx)(n.code,{children:"bounds"})," is smaller than this value."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"opts.maxZoom"}),"=",(0,r.jsx)(n.code,{children:"24"})," (number, optional) - The returned zoom value will be capped to this value. Avoids returning infinite ",(0,r.jsx)(n.code,{children:"zoom"})," when the supplied ",(0,r.jsx)(n.code,{children:"bounds"})," have zero width or height deltas."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A new ",(0,r.jsx)(n.code,{children:"WebMercatorViewport"})," instance"]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"getmapcenterbylnglatpositionoptions-object-number-number",children:(0,r.jsx)(n.code,{children:"getMapCenterByLngLatPosition(options: object): [number, number]"})}),"\n",(0,r.jsx)(n.p,{children:"Get the map center that place a given [lng, lat] coordinate at screen point [x, y]."}),"\n",(0,r.jsx)(n.p,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options.lngLat"})," (Array, required) - [lng,lat] coordinates of a location on the sphere."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"options.pos"})," (Array, required) - [x,y] coordinates of a pixel on screen."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Returns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[longitude, latitude]"})," as the new map center"]}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,d)=>{d.d(n,{R:()=>s,x:()=>c});var r=d(6540);const i={},t=r.createContext(i);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);