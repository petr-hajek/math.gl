"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[44],{3653:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>o});var s=i(4848),l=i(8453);const r={},c="Math Utility Functions",a={id:"modules/core/api-reference/utilities",title:"Math Utility Functions",description:"GLSL math function equivalents. Work on both single values and vectors.",source:"@site/../docs/modules/core/api-reference/utilities.md",sourceDirName:"modules/core/api-reference",slug:"/modules/core/api-reference/utilities",permalink:"/math.gl/docs/modules/core/api-reference/utilities",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/core/api-reference/utilities.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"SphericalCoordinates",permalink:"/math.gl/docs/modules/core/api-reference/spherical-coordinates"},next:{title:"Vector",permalink:"/math.gl/docs/modules/core/api-reference/vector"}},d={},o=[{value:"Usage",id:"usage",level:2},{value:"Functions",id:"functions",level:2},{value:"configure",id:"configure",level:3},{value:"checkNumber",id:"checknumber",level:3},{value:"formatValue",id:"formatvalue",level:3},{value:"isArray",id:"isarray",level:3},{value:"clone",id:"clone",level:3},{value:"toRadians",id:"toradians",level:3},{value:"toDegrees",id:"todegrees",level:3},{value:"equals",id:"equals",level:3},{value:"exactEquals",id:"exactequals",level:3},{value:"GLSL equivalents",id:"glsl-equivalents",level:2},{value:"radians",id:"radians",level:3},{value:"degrees",id:"degrees",level:3},{value:"sin",id:"sin",level:3},{value:"cos",id:"cos",level:3},{value:"tan",id:"tan",level:3},{value:"asin",id:"asin",level:3},{value:"acos",id:"acos",level:3},{value:"atan",id:"atan",level:3},{value:"clamp",id:"clamp",level:3},{value:"Remarks",id:"remarks",level:2}];function t(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"math-utility-functions",children:"Math Utility Functions"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL math function equivalents. Work on both single values and vectors."}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {config, equals} from '@math.gl/core';\n"})}),"\n",(0,s.jsx)(n.p,{children:"Setting configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {config} from '@math.gl/core';\nconfig.EPSILON = 1e-12;\nconfig.debug = true;\nconfig.printRowMajor = true;\nconfig.precision = 4;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.h3,{id:"configure",children:"configure"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"configure(options)"})}),"\n",(0,s.jsx)(n.h3,{id:"checknumber",children:"checkNumber"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"checkNumber(value)"})}),"\n",(0,s.jsx)(n.h3,{id:"formatvalue",children:"formatValue"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"formatValue(value, precision = config.precision || 4)"})}),"\n",(0,s.jsx)(n.h3,{id:"isarray",children:"isArray"}),"\n",(0,s.jsx)(n.p,{children:"Returns true if value is either an array or a typed array"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"isArray(value)"})}),"\n",(0,s.jsx)(n.p,{children:"Note: does not return true for ArrayBuffers and DataViews"}),"\n",(0,s.jsx)(n.h3,{id:"clone",children:"clone"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"clone(array)If the array has a clone function, calls it, otherwise returns a copy"})}),"\n",(0,s.jsx)(n.h3,{id:"toradians",children:"toRadians"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"toRadians(degrees)"})}),"\n",(0,s.jsx)(n.p,{children:"Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"todegrees",children:"toDegrees"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"toDegrees(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"equals",children:"equals"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"equals(a, b, epsilon)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Works on single values and vectors"}),"\n",(0,s.jsxs)(n.li,{children:["Numeric values need to be closer than ",(0,s.jsx)(n.code,{children:"config.EPSILON"})]}),"\n",(0,s.jsxs)(n.li,{children:["Objects will be compared with their ",(0,s.jsx)(n.code,{children:".equals()"})," method if present."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"exactequals",children:"exactEquals"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"exactEquals(a, b)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Works on single values and vectors."}),"\n",(0,s.jsx)(n.li,{children:"Numeric values need to be exactly identical"}),"\n",(0,s.jsxs)(n.li,{children:["Objects will be compared with their ",(0,s.jsx)(n.code,{children:".exactEquals()"})," method if present."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"glsl-equivalents",children:"GLSL equivalents"}),"\n",(0,s.jsx)(n.h3,{id:"radians",children:"radians"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"radians(degrees)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"degrees",children:"degrees"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"degrees(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"sin",children:"sin"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"sin(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"cos",children:"cos"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"cos(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"tan",children:"tan"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"tan(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"asin",children:"asin"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"asin(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"acos",children:"acos"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"acos(radians)"})}),"\n",(0,s.jsx)(n.p,{children:"GLSL equivalent: Works on single values and vectors"}),"\n",(0,s.jsx)(n.h3,{id:"atan",children:"atan"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"atan(radians)"})}),"\n",(0,s.jsx)(n.h3,{id:"clamp",children:"clamp"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"clamp(value, min, max)"})}),"\n",(0,s.jsx)(n.h2,{id:"remarks",children:"Remarks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When setting global configs, you may need to consider the order of code loadint when using ",(0,s.jsx)(n.code,{children:"imports"})," and ",(0,s.jsx)(n.code,{children:"requires"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>a});var s=i(6540);const l={},r=s.createContext(l);function c(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);