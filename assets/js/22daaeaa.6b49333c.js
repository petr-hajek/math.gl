"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[2688],{4515:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>x,frontMatter:()=>s,metadata:()=>c,toc:()=>t});var o=i(5893),d=i(1151);const s={},l="AxisAlignedBoundingBox",c={id:"modules/culling/api-reference/axis-aligned-bounding-box",title:"AxisAlignedBoundingBox",description:"An AxisAlignedBoundingBox is a closed and convex cuboid that is aligned with the orthogonal axes.",source:"@site/../docs/modules/culling/api-reference/axis-aligned-bounding-box.md",sourceDirName:"modules/culling/api-reference",slug:"/modules/culling/api-reference/axis-aligned-bounding-box",permalink:"/math.gl/docs/modules/culling/api-reference/axis-aligned-bounding-box",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/website/../docs/modules/culling/api-reference/axis-aligned-bounding-box.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/math.gl/docs/modules/culling/"},next:{title:"BoundingSphere",permalink:"/math.gl/docs/modules/culling/api-reference/bounding-sphere"}},r={},t=[{value:"Inheritance",id:"inheritance",level:2},{value:"Global Functions",id:"global-functions",level:2},{value:"<code>makeAxisAlignedBoundingBoxFromPoints(positions : Array</code>[3][], result? : AxisAlignedBoundingBox) : AxisAlignedBoundingBox",id:"makeaxisalignedboundingboxfrompointspositions--array3-result--axisalignedboundingbox--axisalignedboundingbox",level:3},{value:"Fields",id:"fields",level:2},{value:"<code>center: Vector3 = [0, 0, 0]</code>",id:"center-vector3--0-0-0",level:3},{value:"<code>halfDiagonal: Vector3</code>",id:"halfdiagonal-vector3",level:3},{value:"<code>minimum: Vector3</code>",id:"minimum-vector3",level:3},{value:"<code>maximum: Vector3</code>",id:"maximum-vector3",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>constructor(minimum = [0, 0, 0], maximum = [0, 0, 0])</code>",id:"constructorminimum--0-0-0-maximum--0-0-0",level:3},{value:"<code>constructor</code>",id:"constructor",level:3},{value:"<code>clone() : AxisAlignedBoundingBox</code>",id:"clone--axisalignedboundingbox",level:3},{value:"<code>equals(right : AxisAlignedBoundingBox) : Boolean</code>",id:"equalsright--axisalignedboundingbox--boolean",level:3},{value:"<code>intersectPlane(plane : Plane) : INTERSECTION</code>",id:"intersectplaneplane--plane--intersection",level:3},{value:"<code>distanceTo(point : Number[3]) : Number</code>",id:"distancetopoint--number3--number",level:3},{value:"<code>distanceSquaredTo(point : Number[3]) : Number</code>",id:"distancesquaredtopoint--number3--number",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"axisalignedboundingbox",children:"AxisAlignedBoundingBox"}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})," is a closed and convex cuboid that is aligned with the orthogonal axes."]}),"\n",(0,o.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})," can be created using two corners of the box:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {AxisAlignedBoundingBox} from '@math.gl/culling';\n\nconst box = new AxisAlignedBoundingBox([-1, -1, -1], [1, 1, 1]);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Or from a collection of points:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {makeAxisAlignedBoundingBoxFromPoints} from '@math.gl/culling';\n\nconst box = makeAxisAlignedBoundingBoxFromPoints([\n  [2, 0, 0],\n  [-2, 0, 0]\n]);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"class AxisAlignedBoundingBox implements"})," ",(0,o.jsx)(n.a,{href:"./bounding-volume",children:(0,o.jsx)(n.code,{children:"BoundingVolume"})}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"global-functions",children:"Global Functions"}),"\n",(0,o.jsxs)(n.h3,{id:"makeaxisalignedboundingboxfrompointspositions--array3-result--axisalignedboundingbox--axisalignedboundingbox",children:[(0,o.jsx)(n.code,{children:"makeAxisAlignedBoundingBoxFromPoints(positions : Array"}),"[3][], result? : AxisAlignedBoundingBox) : AxisAlignedBoundingBox"]}),"\n",(0,o.jsxs)(n.p,{children:["Computes an instance of an ",(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})," of the given positions."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"positions"})," List of ",(0,o.jsx)(n.code,{children:"Vector3"})," points that the bounding box will enclose."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"result"})," Optional object onto which to store the result."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,o.jsx)(n.h3,{id:"center-vector3--0-0-0",children:(0,o.jsx)(n.code,{children:"center: Vector3 = [0, 0, 0]"})}),"\n",(0,o.jsx)(n.p,{children:"The center position of the box."}),"\n",(0,o.jsx)(n.h3,{id:"halfdiagonal-vector3",children:(0,o.jsx)(n.code,{children:"halfDiagonal: Vector3"})}),"\n",(0,o.jsx)(n.p,{children:"The positive diagonal vector."}),"\n",(0,o.jsx)(n.h3,{id:"minimum-vector3",children:(0,o.jsx)(n.code,{children:"minimum: Vector3"})}),"\n",(0,o.jsx)(n.p,{children:"The minimum corner of the bounding box."}),"\n",(0,o.jsx)(n.h3,{id:"maximum-vector3",children:(0,o.jsx)(n.code,{children:"maximum: Vector3"})}),"\n",(0,o.jsx)(n.p,{children:"The maximum corner of the bounding box."}),"\n",(0,o.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(n.h3,{id:"constructorminimum--0-0-0-maximum--0-0-0",children:(0,o.jsx)(n.code,{children:"constructor(minimum = [0, 0, 0], maximum = [0, 0, 0])"})}),"\n",(0,o.jsx)(n.h3,{id:"constructor",children:(0,o.jsx)(n.code,{children:"constructor"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"minimum=Vector3.ZERO"}),": ",(0,o.jsx)(n.code,{children:"Vector3"})," The minimum corner of the box, i.e. ",(0,o.jsx)(n.code,{children:"[xMin, yMin, zMin]"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"maximum=Vector3.ZERO"}),": ",(0,o.jsx)(n.code,{children:"Vector3"})," The maximum corner of the box, i.e. ",(0,o.jsx)(n.code,{children:"[xMax, yMax, zMax]"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"clone--axisalignedboundingbox",children:(0,o.jsx)(n.code,{children:"clone() : AxisAlignedBoundingBox"})}),"\n",(0,o.jsxs)(n.p,{children:["Duplicates a ",(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})," instance."]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A new ",(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})," instance."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"equalsright--axisalignedboundingbox--boolean",children:(0,o.jsx)(n.code,{children:"equals(right : AxisAlignedBoundingBox) : Boolean"})}),"\n",(0,o.jsxs)(n.p,{children:["Compares the provided ",(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})," componentwise and returns ",(0,o.jsx)(n.code,{children:"true"})," if they are equal, ",(0,o.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"right"})," The second ",(0,o.jsx)(n.code,{children:"AxisAlignedBoundingBox"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"true"})," if left and right are equal, ",(0,o.jsx)(n.code,{children:"false"})," otherwise."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"intersectplaneplane--plane--intersection",children:(0,o.jsx)(n.code,{children:"intersectPlane(plane : Plane) : INTERSECTION"})}),"\n",(0,o.jsx)(n.p,{children:"Determines which side of a plane the axis-aligned bounding box is located."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"plane"})," The plane to test against."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"INTERSECTION.INSIDE"})," if the entire box is on the side of the plane the normal is pointing"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"INTERSECTION.OUTSIDE"})," if the entire box is on the opposite side, and"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"INTERSECTION.INTERSECTING"})," if the box intersects the plane."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"distancetopoint--number3--number",children:(0,o.jsx)(n.code,{children:"distanceTo(point : Number[3]) : Number"})}),"\n",(0,o.jsx)(n.p,{children:"Computes the estimated distance from the closest point on a bounding box to a point."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"point"})," The point"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The estimated distance from the bounding sphere to the point."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"distancesquaredtopoint--number3--number",children:(0,o.jsx)(n.code,{children:"distanceSquaredTo(point : Number[3]) : Number"})}),"\n",(0,o.jsx)(n.p,{children:"Computes the estimated distance squared from the closest point on a bounding box to a point."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"point"})," The point"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Returns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The estimated distance squared from the bounding sphere to the point."}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>l});var o=i(7294);const d={},s=o.createContext(d);function l(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:l(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);