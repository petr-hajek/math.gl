"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1807],{7632:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var o=i(4848),s=i(8453);const r={},l="polygon-utils",t={id:"modules/polygon/api-reference/polygon-utils",title:"polygon-utils",description:"A set of polygon-related utility functions. Utility functions are available for flat arrays and for arrays of points. Note: the \\*Points set of functions is used for arrays of points, and is separated for performance and backwards compatibility reasons.",source:"@site/../docs/modules/polygon/api-reference/polygon-utils.md",sourceDirName:"modules/polygon/api-reference",slug:"/modules/polygon/api-reference/polygon-utils",permalink:"/math.gl/docs/modules/polygon/api-reference/polygon-utils",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/math.gl/tree/master/docs/../docs/modules/polygon/api-reference/polygon-utils.md",tags:[],version:"current",frontMatter:{}},d={},c=[{value:"Usage",id:"usage",level:2},{value:"Types",id:"types",level:2},{value:"PolygonParams",id:"polygonparams",level:3},{value:"Functions",id:"functions",level:2},{value:"modifyPolygonWindingDirection",id:"modifypolygonwindingdirection",level:3},{value:"getPolygonSignedArea",id:"getpolygonsignedarea",level:3},{value:"getPolygonWindingDirection",id:"getpolygonwindingdirection",level:3},{value:"forEachSegmentInPolygon",id:"foreachsegmentinpolygon",level:3},{value:"modifyPolygonWindingDirectionPoints",id:"modifypolygonwindingdirectionpoints",level:3},{value:"getPolygonSignedAreaPoints",id:"getpolygonsignedareapoints",level:3},{value:"getPolygonWindingDirectionPoints",id:"getpolygonwindingdirectionpoints",level:3},{value:"forEachSegmentInPolygonPoints",id:"foreachsegmentinpolygonpoints",level:3}];function a(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"polygon-utils",children:"polygon-utils"})}),"\n",(0,o.jsx)(e.p,{children:"A set of polygon-related utility functions. Utility functions are available for flat arrays and for arrays of points. Note: the *Points set of functions is used for arrays of points, and is separated for performance and backwards compatibility reasons."}),"\n",(0,o.jsx)(e.h2,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import {getPolygonWindingDirection} from '@math.gl/polygon';\n"})}),"\n",(0,o.jsx)(e.h2,{id:"types",children:"Types"}),"\n",(0,o.jsx)(e.h3,{id:"polygonparams",children:"PolygonParams"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"PolygonParams"})}),"\n",(0,o.jsx)(e.p,{children:"Fields:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"start"})," (number) - Start index of the polygon in the array of positions. Defaults to 0."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"end"})," (number) - End index of the polygon in the array of positions. Defaults to number of positions."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"size"})," (Number) - Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"isClosed"})," (Boolean) - Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"plane"})," ('xy' | 'yz' | 'xz') - The 2D projection plane on which to calculate the area of a 3D polygon. Default ",(0,o.jsx)(e.code,{children:"'xy'"}),"."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"functions",children:"Functions"}),"\n",(0,o.jsx)(e.h3,{id:"modifypolygonwindingdirection",children:"modifyPolygonWindingDirection"}),"\n",(0,o.jsx)(e.p,{children:"Checks winding direction of the polygon and reverses the polygon in case if opposite winding direction. Note: points are modified in-place."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"modifyPolygonWindingDirection(points, direction, params)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array|TypedArray) - a flat array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"direction"})," (Number) - Requested winding direction. A positive 1 for clockwise, -1 for counter clockwise."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Returns:"}),"\n",(0,o.jsx)(e.p,{children:"Returns true if the winding direction was changed."}),"\n",(0,o.jsx)(e.h3,{id:"getpolygonsignedarea",children:"getPolygonSignedArea"}),"\n",(0,o.jsx)(e.p,{children:"Returns signed area of the polygon."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"getPolygonSignedArea(points, options, plane)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array|TypedArray) - a flat array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams, optional) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Returns:"}),"\n",(0,o.jsx)(e.p,{children:"Signed area of the polygon."}),"\n",(0,o.jsx)(e.h3,{id:"getpolygonwindingdirection",children:"getPolygonWindingDirection"}),"\n",(0,o.jsx)(e.p,{children:"Returns winding direction of the polygon."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"getPolygonWindingDirection(points, options)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array|TypedArray) - a flat array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Returns:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A positive number is clockwise."}),"\n",(0,o.jsx)(e.li,{children:"A negative number is counter clockwise."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"foreachsegmentinpolygon",children:"forEachSegmentInPolygon"}),"\n",(0,o.jsx)(e.p,{children:"Calls visitor callback for each segment in the polygon."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"forEachSegmentInPolygon(points, (p1x, p1y, p2x, p2y, ind1, ind2) => ...), options"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array[]|TypedArray[]) - a flat array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"visitor"})," (SegmentVisitorFlat) - a callback to call for each segment of the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"modifypolygonwindingdirectionpoints",children:"modifyPolygonWindingDirectionPoints"}),"\n",(0,o.jsx)(e.p,{children:"Checks winding direction of the polygon and reverses the polygon in case if opposite winding direction. Note: points are modified in-place."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"modifyPolygonWindingDirectionPoints(points, direction, options)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array[]|TypedArray[]) - an array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"direction"})," (Number) - Requested winding direction. A positive 1 for clockwise, -1 for counter clockwise."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Returns:"}),"\n",(0,o.jsx)(e.p,{children:"Returns true if the winding direction was changed."}),"\n",(0,o.jsx)(e.h3,{id:"getpolygonsignedareapoints",children:"getPolygonSignedAreaPoints"}),"\n",(0,o.jsx)(e.p,{children:"Returns signed area of the polygon."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"getPolygonSignedAreaPoints(points, options)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array[]|TypedArray[]) - an array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Returns:"}),"\n",(0,o.jsx)(e.p,{children:"Signed area of the polygon."}),"\n",(0,o.jsx)(e.h3,{id:"getpolygonwindingdirectionpoints",children:"getPolygonWindingDirectionPoints"}),"\n",(0,o.jsx)(e.p,{children:"Returns winding direction of the polygon."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"getPolygonWindingDirectionPoints(points, options)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array[]|TypedArray[]) - an array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Returns:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A positive number is clockwise."}),"\n",(0,o.jsx)(e.li,{children:"A negative number is counter clockwise."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"foreachsegmentinpolygonpoints",children:"forEachSegmentInPolygonPoints"}),"\n",(0,o.jsx)(e.p,{children:"Calls visitor callback for each segment in the polygon."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"forEachSegmentInPolygonPoints(points, (p1, p2, ind1, ind2) => ..., options)"})}),"\n",(0,o.jsx)(e.p,{children:"Arguments:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"points"})," (Array[]|TypedArray[]) - an array of the points that define the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"visitor"})," (SegmentVisitor) - a callback to call for each segment of the polygon."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"options"})," (PolygonParams) - Polygon parameters."]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(a,{...n})}):a(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>t});var o=i(6540);const s={},r=o.createContext(s);function l(n){const e=o.useContext(r);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);